// Generated by psc version 0.6.8
var PS = PS || {};
PS.Prelude = (function () {
    "use strict";
    
    function showStringImpl(s) {
      return JSON.stringify(s);
    }
    ;
    
    function showNumberImpl(n) {
      return n.toString();
    }
    ;
    
    function numAdd(n1) {
      return function(n2) {
        return n1 + n2;
      };
    }
    ;
    
    function numSub(n1) {
      return function(n2) {
        return n1 - n2;
      };
    }
    ;
    
    function numMul(n1) {
      return function(n2) {
        return n1 * n2;
      };
    }
    ;
    
    function numDiv(n1) {
      return function(n2) {
        return n1 / n2;
      };
    }
    ;
    
    function refEq(r1) {
      return function(r2) {
        return r1 === r2;
      };
    }
    ;
    
    function refIneq(r1) {
      return function(r2) {
        return r1 !== r2;
      };
    }
    ;
    
    function boolAnd(b1) {
      return function(b2) {
        return b1 && b2;
      };
    }
    ;
    
    function boolOr(b1) {
      return function(b2) {
        return b1 || b2;
      };
    }
    ;
    
    function boolNot(b) {
      return !b;
    }
    ;
    
    function concatString(s1) {
      return function(s2) {
        return s1 + s2;
      };
    }
    ;
    var Unit = function (x) {
        return x;
    };
    var Semigroupoid = function ($less$less$less) {
        this["<<<"] = $less$less$less;
    };
    var Show = function (show) {
        this.show = show;
    };
    var Functor = function ($less$dollar$greater) {
        this["<$>"] = $less$dollar$greater;
    };
    var Apply = function ($less$times$greater, __superclass_Prelude$dotFunctor_0) {
        this["<*>"] = $less$times$greater;
        this["__superclass_Prelude.Functor_0"] = __superclass_Prelude$dotFunctor_0;
    };
    var Applicative = function (__superclass_Prelude$dotApply_0, pure) {
        this["__superclass_Prelude.Apply_0"] = __superclass_Prelude$dotApply_0;
        this.pure = pure;
    };
    var Bind = function ($greater$greater$eq, __superclass_Prelude$dotApply_0) {
        this[">>="] = $greater$greater$eq;
        this["__superclass_Prelude.Apply_0"] = __superclass_Prelude$dotApply_0;
    };
    var Monad = function (__superclass_Prelude$dotApplicative_0, __superclass_Prelude$dotBind_1) {
        this["__superclass_Prelude.Applicative_0"] = __superclass_Prelude$dotApplicative_0;
        this["__superclass_Prelude.Bind_1"] = __superclass_Prelude$dotBind_1;
    };
    
    /**
     *  | Addition and multiplication
     */
    var Semiring = function ($times, $plus, one, zero) {
        this["*"] = $times;
        this["+"] = $plus;
        this.one = one;
        this.zero = zero;
    };
    
    /**
     *  | Semiring with modulo operation and division where
     *  | ```a / b * b + (a `mod` b) = a```
     */
    var ModuloSemiring = function ($div, __superclass_Prelude$dotSemiring_0, mod) {
        this["/"] = $div;
        this["__superclass_Prelude.Semiring_0"] = __superclass_Prelude$dotSemiring_0;
        this.mod = mod;
    };
    
    /**
     *  | Addition, multiplication, and subtraction
     */
    var Ring = function ($minus, __superclass_Prelude$dotSemiring_0) {
        this["-"] = $minus;
        this["__superclass_Prelude.Semiring_0"] = __superclass_Prelude$dotSemiring_0;
    };
    var Eq = function ($div$eq, $eq$eq) {
        this["/="] = $div$eq;
        this["=="] = $eq$eq;
    };
    var BoolLike = function ($amp$amp, not, $bar$bar) {
        this["&&"] = $amp$amp;
        this.not = not;
        this["||"] = $bar$bar;
    };
    var Semigroup = function ($less$greater) {
        this["<>"] = $less$greater;
    };
    var $bar$bar = function (dict) {
        return dict["||"];
    };
    var $greater$greater$eq = function (dict) {
        return dict[">>="];
    };
    var $eq$eq = function (dict) {
        return dict["=="];
    };
    var $less$greater = function (dict) {
        return dict["<>"];
    };
    var $less$less$less = function (dict) {
        return dict["<<<"];
    };
    var $less$times$greater = function (dict) {
        return dict["<*>"];
    };
    var $less$dollar$greater = function (dict) {
        return dict["<$>"];
    };
    
    /**
     *  | Semiring with modulo operation and division where
     *  | ```a / b * b + (a `mod` b) = a```
     */
    var $div = function (dict) {
        return dict["/"];
    };
    
    /**
     *  | Addition, multiplication, and subtraction
     */
    var $minus = function (dict) {
        return dict["-"];
    };
    var $plus$plus = function (__dict_Semigroup_2) {
        return $less$greater(__dict_Semigroup_2);
    };
    
    /**
     *  | Addition and multiplication
     */
    var $plus = function (dict) {
        return dict["+"];
    };
    var $dollar = function (f) {
        return function (x) {
            return f(x);
        };
    };
    var unit = {};
    var showString = new Show(showStringImpl);
    var showNumber = new Show(showNumberImpl);
    var show = function (dict) {
        return dict.show;
    };
    var semiringNumber = new Semiring(numMul, numAdd, 1, 0);
    var semigroupoidArr = new Semigroupoid(function (f) {
        return function (g) {
            return function (x) {
                return f(g(x));
            };
        };
    });
    var semigroupString = new Semigroup(concatString);
    var ringNumber = new Ring(numSub, function () {
        return semiringNumber;
    });
    var pure = function (dict) {
        return dict.pure;
    };
    var $$return = function (__dict_Monad_5) {
        return pure(__dict_Monad_5["__superclass_Prelude.Applicative_0"]());
    };
    var moduloSemiringNumber = new ModuloSemiring(numDiv, function () {
        return semiringNumber;
    }, function (_60) {
        return function (_61) {
            return 0;
        };
    });
    var liftA1 = function (__dict_Applicative_8) {
        return function (f) {
            return function (a) {
                return $less$times$greater(__dict_Applicative_8["__superclass_Prelude.Apply_0"]())(pure(__dict_Applicative_8)(f))(a);
            };
        };
    };
    var eqNumber = new Eq(refIneq, refEq);
    
    /**
     *  | Returns its first argument and ignores its second.
     */
    var $$const = function (_54) {
        return function (_55) {
            return _54;
        };
    };
    var boolLikeBoolean = new BoolLike(boolAnd, boolNot, boolOr);
    var ap = function (__dict_Monad_16) {
        return function (f) {
            return function (a) {
                return $greater$greater$eq(__dict_Monad_16["__superclass_Prelude.Bind_1"]())(f)(function (_2) {
                    return $greater$greater$eq(__dict_Monad_16["__superclass_Prelude.Bind_1"]())(a)(function (_1) {
                        return $$return(__dict_Monad_16)(_2(_1));
                    });
                });
            };
        };
    };
    return {
        Unit: Unit, 
        Semigroup: Semigroup, 
        BoolLike: BoolLike, 
        Eq: Eq, 
        Ring: Ring, 
        ModuloSemiring: ModuloSemiring, 
        Semiring: Semiring, 
        Monad: Monad, 
        Bind: Bind, 
        Applicative: Applicative, 
        Apply: Apply, 
        Functor: Functor, 
        Show: Show, 
        Semigroupoid: Semigroupoid, 
        unit: unit, 
        "++": $plus$plus, 
        "<>": $less$greater, 
        "||": $bar$bar, 
        refIneq: refIneq, 
        refEq: refEq, 
        "==": $eq$eq, 
        "-": $minus, 
        "/": $div, 
        "+": $plus, 
        ap: ap, 
        "return": $$return, 
        ">>=": $greater$greater$eq, 
        liftA1: liftA1, 
        pure: pure, 
        "<*>": $less$times$greater, 
        "<$>": $less$dollar$greater, 
        show: show, 
        "$": $dollar, 
        "<<<": $less$less$less, 
        "const": $$const, 
        semigroupoidArr: semigroupoidArr, 
        showString: showString, 
        showNumber: showNumber, 
        semiringNumber: semiringNumber, 
        ringNumber: ringNumber, 
        moduloSemiringNumber: moduloSemiringNumber, 
        eqNumber: eqNumber, 
        boolLikeBoolean: boolLikeBoolean, 
        semigroupString: semigroupString
    };
})();
var PS = PS || {};
PS.Data_Function = (function () {
    "use strict";
    var Prelude = PS.Prelude;
    
    function runFn2(fn) {
      return function(a) {
        return function(b) {
          return fn(a, b);
        };
      };
    }
    ;
    
    function runFn3(fn) {
      return function(a) {
        return function(b) {
          return function(c) {
            return fn(a, b, c);
          };
        };
      };
    }
    ;
    return {
        runFn3: runFn3, 
        runFn2: runFn2
    };
})();
var PS = PS || {};
PS.Control_Monad_Eff = (function () {
    "use strict";
    var Prelude = PS.Prelude;
    
    function returnE(a) {
      return function() {
        return a;
      };
    }
    ;
    
    function bindE(a) {
      return function(f) {
        return function() {
          return f(a())();
        };
      };
    }
    ;
    var monadEff = new Prelude.Monad(function () {
        return applicativeEff;
    }, function () {
        return bindEff;
    });
    var bindEff = new Prelude.Bind(bindE, function () {
        return applyEff;
    });
    var applyEff = new Prelude.Apply(Prelude.ap(monadEff), function () {
        return functorEff;
    });
    var applicativeEff = new Prelude.Applicative(function () {
        return applyEff;
    }, returnE);
    var functorEff = new Prelude.Functor(Prelude.liftA1(applicativeEff));
    return {
        bindE: bindE, 
        returnE: returnE, 
        functorEff: functorEff, 
        applyEff: applyEff, 
        applicativeEff: applicativeEff, 
        bindEff: bindEff, 
        monadEff: monadEff
    };
})();
var PS = PS || {};
PS.Control_Monad_Eff_Exception = (function () {
    "use strict";
    var Prelude = PS.Prelude;
    var Control_Monad_Eff = PS.Control_Monad_Eff;
    
  function error(msg) {
    return new Error(msg);
  }
  ;
    return {
        error: error
    };
})();
var PS = PS || {};
PS.Debug_Trace = (function () {
    "use strict";
    var Prelude = PS.Prelude;
    var Control_Monad_Eff = PS.Control_Monad_Eff;
    
    function trace(s) {
      return function() {
        console.log(s);
        return {};
      };
    }
    ;
    return {
        trace: trace
    };
})();
var PS = PS || {};
PS.Control_Alt = (function () {
    "use strict";
    var Prelude = PS.Prelude;
    
    /**
     *  | The `Alt` type class identifies an associative operation on a type
     *  | constructor.  It is similar to `Semigroup`, except that it applies to
     *  | types of kind `* -> *`, like `Array` or `List`, rather than concrete types
     *  | `String` or `Number`.
     *  |
     *  | `Alt` instances are required to satisfy the following laws:
     *  |
     *  | - Associativity: `(x <|> y) <|> z == x <|> (y <|> z)`
     *  | - Distributivity: `f <$> (x <|> y) == (f <$> x) <|> (f <$> y)`
     *  |
     *  | For example, the `Array` (`[]`) type is an instance of `Alt`, where
     *  | `(<|>)` is defined to be concatenation.
     */
    var Alt = function ($less$bar$greater, __superclass_Prelude$dotFunctor_0) {
        this["<|>"] = $less$bar$greater;
        this["__superclass_Prelude.Functor_0"] = __superclass_Prelude$dotFunctor_0;
    };
    
    /**
     *  | The `Alt` type class identifies an associative operation on a type
     *  | constructor.  It is similar to `Semigroup`, except that it applies to
     *  | types of kind `* -> *`, like `Array` or `List`, rather than concrete types
     *  | `String` or `Number`.
     *  |
     *  | `Alt` instances are required to satisfy the following laws:
     *  |
     *  | - Associativity: `(x <|> y) <|> z == x <|> (y <|> z)`
     *  | - Distributivity: `f <$> (x <|> y) == (f <$> x) <|> (f <$> y)`
     *  |
     *  | For example, the `Array` (`[]`) type is an instance of `Alt`, where
     *  | `(<|>)` is defined to be concatenation.
     */
    var $less$bar$greater = function (dict) {
        return dict["<|>"];
    };
    return {
        Alt: Alt, 
        "<|>": $less$bar$greater
    };
})();
var PS = PS || {};
PS.Data_Either = (function () {
    "use strict";
    var Prelude = PS.Prelude;
    var Control_Alt = PS.Control_Alt;
    var Control_Extend = PS.Control_Extend;
    
    /**
     *  | The `Either` type is used to represent a choice between two types of value.
     *  |
     *  | A common use case for `Either` is error handling, where `Left` is used to
     *  | carry an error value and `Right` is used to carry a success value.
     */
    var Left = (function () {
        function Left(value0) {
            this.value0 = value0;
        };
        Left.create = function (value0) {
            return new Left(value0);
        };
        return Left;
    })();
    
    /**
     *  | The `Either` type is used to represent a choice between two types of value.
     *  |
     *  | A common use case for `Either` is error handling, where `Left` is used to
     *  | carry an error value and `Right` is used to carry a success value.
     */
    var Right = (function () {
        function Right(value0) {
            this.value0 = value0;
        };
        Right.create = function (value0) {
            return new Right(value0);
        };
        return Right;
    })();
    
    /**
     *  | Takes two functions and an `Either` value, if the value is a `Left` the
     *  | inner value is applied to the first function, if the value is a `Right`
     *  | the inner value is applied to the second function.
     *  |
     *  | ``` purescript
     *  | either f g (Left x) == f x
     *  | either f g (Right y) == g y
     *  | ```
     */
    var either = function (_98) {
        return function (_99) {
            return function (_100) {
                if (_100 instanceof Left) {
                    return _98(_100.value0);
                };
                if (_100 instanceof Right) {
                    return _99(_100.value0);
                };
                throw new Error("Failed pattern match");
            };
        };
    };
    return {
        Left: Left, 
        Right: Right, 
        either: either
    };
})();
var PS = PS || {};
PS.Control_Monad_Eff_Class = (function () {
    "use strict";
    var Prelude = PS.Prelude;
    var Control_Monad_Trans = PS.Control_Monad_Trans;
    var Data_Monoid = PS.Data_Monoid;
    var Control_Monad_Eff = PS.Control_Monad_Eff;
    var Control_Monad_Maybe_Trans = PS.Control_Monad_Maybe_Trans;
    var Control_Monad_Error_Trans = PS.Control_Monad_Error_Trans;
    var Control_Monad_State_Trans = PS.Control_Monad_State_Trans;
    var Control_Monad_Writer_Trans = PS.Control_Monad_Writer_Trans;
    var Control_Monad_Reader_Trans = PS.Control_Monad_Reader_Trans;
    var Control_Monad_RWS_Trans = PS.Control_Monad_RWS_Trans;
    
    /**
     *  | The `MonadEff` class captures those monads which support native effects.
     *  |
     *  | Instances are provided for `Eff` itself, and the standard monad transformers.
     *  |
     *  | `liftEff` can be used in any appropriate monad transformer stack to lift an action
     *  | of type `Eff eff a` into the monad.
     *  |
     *  | Note that `MonadEff` is parameterized by the row of effects, so type inference can be
     *  | tricky. It is generally recommended to either work with a polymorphic row of effects,
     *  | or a concrete, closed row of effects such as `(trace :: Trace)`.
     */
    var MonadEff = function (__superclass_Prelude$dotMonad_0, liftEff) {
        this["__superclass_Prelude.Monad_0"] = __superclass_Prelude$dotMonad_0;
        this.liftEff = liftEff;
    };
    
    /**
     *  | The `MonadEff` class captures those monads which support native effects.
     *  |
     *  | Instances are provided for `Eff` itself, and the standard monad transformers.
     *  |
     *  | `liftEff` can be used in any appropriate monad transformer stack to lift an action
     *  | of type `Eff eff a` into the monad.
     *  |
     *  | Note that `MonadEff` is parameterized by the row of effects, so type inference can be
     *  | tricky. It is generally recommended to either work with a polymorphic row of effects,
     *  | or a concrete, closed row of effects such as `(trace :: Trace)`.
     */
    var liftEff = function (dict) {
        return dict.liftEff;
    };
    return {
        MonadEff: MonadEff, 
        liftEff: liftEff
    };
})();
var PS = PS || {};
PS.Control_Monad_Error_Class = (function () {
    "use strict";
    var Prelude = PS.Prelude;
    var Control_Monad_Error_Trans = PS.Control_Monad_Error_Trans;
    var Control_Monad_Trans = PS.Control_Monad_Trans;
    var Control_Monad_Maybe_Trans = PS.Control_Monad_Maybe_Trans;
    var Control_Monad_Reader_Trans = PS.Control_Monad_Reader_Trans;
    var Control_Monad_Writer_Trans = PS.Control_Monad_Writer_Trans;
    var Control_Monad_State_Trans = PS.Control_Monad_State_Trans;
    var Control_Monad_Error = PS.Control_Monad_Error;
    var Data_Either = PS.Data_Either;
    var Data_Maybe = PS.Data_Maybe;
    var Data_Monoid = PS.Data_Monoid;
    
    /**
     *  | The `MonadError` type class represents those monads which support errors via
     *  | `throwError` and `catchError`.
     *  |
     *  | - `throwError e` throws the error `e`
     *  | - `catchError x f` calls the error handler `f` if an error is thrown during the
     *  |   evaluation of `x`.
     *  |
     *  | An implementation is provided for `ErrorT`, and for other monad transformers
     *  | defined in this library.
     *  |
     *  | Laws:
     *  |
     *  | - Left zero: `throwError e >>= f = throwError e`
     *  | - Catch: `catchError (throwError e) f = f e`
     *  | - Pure: `catchError (pure a) f = pure a`
     *  | 
     */
    var MonadError = function (catchError, throwError) {
        this.catchError = catchError;
        this.throwError = throwError;
    };
    
    /**
     *  | The `MonadError` type class represents those monads which support errors via
     *  | `throwError` and `catchError`.
     *  |
     *  | - `throwError e` throws the error `e`
     *  | - `catchError x f` calls the error handler `f` if an error is thrown during the
     *  |   evaluation of `x`.
     *  |
     *  | An implementation is provided for `ErrorT`, and for other monad transformers
     *  | defined in this library.
     *  |
     *  | Laws:
     *  |
     *  | - Left zero: `throwError e >>= f = throwError e`
     *  | - Catch: `catchError (throwError e) f = f e`
     *  | - Pure: `catchError (pure a) f = pure a`
     *  | 
     */
    var throwError = function (dict) {
        return dict.throwError;
    };
    return {
        MonadError: MonadError, 
        throwError: throwError
    };
})();
var PS = PS || {};
PS.Control_Monad_Aff = (function () {
    "use strict";
    var Data_Function = PS.Data_Function;
    var Prelude = PS.Prelude;
    var Data_Monoid = PS.Data_Monoid;
    var Data_Either = PS.Data_Either;
    var Control_Monad_Error_Class = PS.Control_Monad_Error_Class;
    var Control_Monad_Eff_Exception = PS.Control_Monad_Eff_Exception;
    var Control_Apply = PS.Control_Apply;
    var Control_Alt = PS.Control_Alt;
    var Control_Plus = PS.Control_Plus;
    var Control_Alternative = PS.Control_Alternative;
    var Control_MonadPlus = PS.Control_MonadPlus;
    var Control_Monad_Eff = PS.Control_Monad_Eff;
    var Control_Monad_Eff_Unsafe = PS.Control_Monad_Eff_Unsafe;
    var Control_Monad_Eff_Class = PS.Control_Monad_Eff_Class;
    
    function _cancelWith(nonCanceler, aff, canceler1) {
      return function(success, error) {
        var canceler2 = aff(success, error);

        return function(e) {
          return function(success, error) {
            var cancellations = 0;
            var result        = false;
            var errored       = false;

            var s = function(bool) {
              cancellations = cancellations + 1;
              result        = result || bool;

              if (cancellations === 2 && !errored) {
                try {
                  success(result);
                } catch (e) {
                  error(e);
                }
              }
            };

            var f = function(err) {
              if (!errored) {
                errored = true;

                error(err);
              }
            };

            canceler2(e)(s, f);
            canceler1(e)(s, f);            

            return nonCanceler;
          };
        };
      };
    }
  ;
    
    function _setTimeout(nonCanceler, millis, aff) {
      return function(success, error) {
        var canceler;

        var timeout = setTimeout(function() {
          canceler = aff(success, error);
        }, millis);

        return function(e) {
          return function(s, f) {
            if (canceler !== undefined) {
              return canceler(e)(s, f);
            } else {
              clearTimeout(timeout);

              try {
                s(true);
              } catch (e) {
                f(e);
              }

              return nonCanceler;
            }
          };
        };
      };
    }
  ;
    
    function _forkAff(nonCanceler, aff) {
      var voidF = function(){};

      return function(success, error) {
        var canceler = aff(voidF, voidF);

        try {
          success(canceler);
        } catch (e) {
          error(e);
        }

        return nonCanceler;
      };
    }
  ;
    
    function _pure(nonCanceler, v) {
      return function(success, error) {
        try {
          success(v);
        } catch (e) {
          error(e);
        }

        return nonCanceler;
      }
    };
    
    function _throwError(nonCanceler, e) {
      return function(success, error) {
        error(e);

        return nonCanceler;
      };
    };
    
    function _fmap(f, aff) {
      return function(success, error) {
        return aff(function(v) {
          try {
            success(f(v));
          } catch (e) {
            error(e);
          }
        }, error);
      };
    };
    
    function _bind(alwaysCanceler, aff, f) {
      return function(success, error) {
        var canceler1, canceler2;

        var isCanceled    = false;
        var requestCancel = false;

        var onCanceler = function(){};

        canceler1 = aff(function(v) {
          if (requestCancel) {
            isCanceled = true;

            return alwaysCanceler;
          } else {
            canceler2 = f(v)(success, error);

            onCanceler(canceler2);

            return canceler2;
          }
        }, error);

        return function(e) {
          return function(s, f) {
            requestCancel = true;

            if (canceler2 !== undefined) {
              return canceler2(e)(s, f);
            } else {
              return canceler1(e)(function(bool) {
                if (bool || isCanceled) {
                  try {
                    s(true);
                  } catch (e) {
                    f(e);
                  }
                } else {
                  onCanceler = function(canceler) {
                    canceler(e)(s, f);
                  };
                }
              }, f);
            }
          };
        };
      };
    };
    
    function _attempt(Left, Right, aff) {
      return function(success, error) {
        return aff(function(v) {
          try {
            success(Right(v));
          } catch (e) {
            error(e);
          }
        }, function(e) {
          try {
            success(Left(e));
          } catch (e) {
            error(e);
          }
        });
      };
    };
    
    function _runAff(errorT, successT, aff) {
      return function() {
        return aff(function(v) {
          try {
            successT(v)();
          } catch (e) {
            errorT(e)();
          }
        }, function(e) {
          errorT(e)();
        });
      };
    };
    
    function _liftEff(nonCanceler, e) {
      return function(success, error) {
        try {
          success(e());
        } catch (e) {
          error(e);
        }

        return nonCanceler;
      };
    };
    
    /**
     *  | A canceler is asynchronous function that can be used to attempt the 
     *  | cancelation of a computation. Returns a boolean flag indicating whether
     *  | or not the cancellation was successful. Many computations may be composite,
     *  | in such cases the flag indicates whether any part of the computation was 
     *  | successfully canceled. The flag should not be used for communication.
     */
    var Canceler = function (x) {
        return x;
    };
    
    /**
     *  | Runs the asynchronous computation. You must supply an error callback and a
     *  | success callback.
     */
    var runAff = function (ex) {
        return function (f) {
            return function (aff) {
                return _runAff(ex, f, aff);
            };
        };
    };
    
    /**
     *  | Converts the asynchronous computation into a synchronous one. All values
     *  | and errors are ignored.
     */
    var launchAff = runAff(Prelude["const"](Prelude.pure(Control_Monad_Eff.applicativeEff)(Prelude.unit)))(Prelude["const"](Prelude.pure(Control_Monad_Eff.applicativeEff)(Prelude.unit)));
    var functorAff = new Prelude.Functor(function (f) {
        return function (fa) {
            return _fmap(f, fa);
        };
    });
    
    /**
     *  | Unwraps the canceler function from the newtype that wraps it.
     */
    var cancel = function (_308) {
        return _308;
    };
    
    /**
     *  | Promotes any error to the value level of the asynchronous monad.
     */
    var attempt = function (aff) {
        return _attempt(Data_Either.Left.create, Data_Either.Right.create, aff);
    };
    
    /**
     *  | Ignores any errors.
     */
    var apathize = function (a) {
        return Prelude["<$>"](functorAff)(Prelude["const"](Prelude.unit))(attempt(a));
    };
    var applyAff = new Prelude.Apply(function (ff) {
        return function (fa) {
            return _bind(alwaysCanceler, ff, function (f) {
                return Prelude["<$>"](functorAff)(f)(fa);
            });
        };
    }, function () {
        return functorAff;
    });
    var applicativeAff = new Prelude.Applicative(function () {
        return applyAff;
    }, function (v) {
        return _pure(nonCanceler, v);
    });
    var nonCanceler = Prelude["const"](Prelude.pure(applicativeAff)(false));
    var alwaysCanceler = Prelude["const"](Prelude.pure(applicativeAff)(true));
    
    /**
     *  | This function allows you to attach a custom canceler to an asynchronous
     *  | computation. If the computation is canceled, then the custom canceler 
     *  | will be run along side the computation's own canceler.
     */
    var cancelWith = function (aff) {
        return function (c) {
            return _cancelWith(nonCanceler, aff, c);
        };
    };
    
    /**
     *  | Forks the specified asynchronous computation so subsequent computations
     *  | will not block on the result of the computation.
     *  |
     *  | Returns a canceler that can be used to attempt cancellation of the 
     *  | forked computation.
     */
    var forkAff = function (aff) {
        return _forkAff(nonCanceler, aff);
    };
    
    /**
     *  | Runs the specified asynchronous computation later, by the specified 
     *  | number of milliseconds.
     */
    var later$prime = function (n) {
        return function (aff) {
            return _setTimeout(nonCanceler, n, aff);
        };
    };
    
    /**
     *  | Runs the asynchronous computation off the current execution context.
     */
    var later = later$prime(0);
    var semigroupCanceler = new Prelude.Semigroup(function (_309) {
        return function (_310) {
            return function (e) {
                return Prelude["<*>"](applyAff)(Prelude["<$>"](functorAff)(Prelude["||"](Prelude.boolLikeBoolean))(_309(e)))(_310(e));
            };
        };
    });
    var bindAff = new Prelude.Bind(function (fa) {
        return function (f) {
            return _bind(alwaysCanceler, fa, f);
        };
    }, function () {
        return applyAff;
    });
    var monadAff = new Prelude.Monad(function () {
        return applicativeAff;
    }, function () {
        return bindAff;
    });
    var monadEffAff = new Control_Monad_Eff_Class.MonadEff(function () {
        return monadAff;
    }, function (eff) {
        return _liftEff(nonCanceler, eff);
    });
    
    /**
     *  | Allows users to catch and throw errors on the error channel of the
     *  | asynchronous computation. See documentation in `purescript-transformers`.
     */
    var monadErrorAff = new Control_Monad_Error_Class.MonadError(function (aff) {
        return function (ex) {
            return Prelude[">>="](bindAff)(attempt(aff))(Data_Either.either(ex)(Prelude.pure(applicativeAff)));
        };
    }, function (e) {
        return _throwError(nonCanceler, e);
    });
    return {
        Canceler: Canceler, 
        runAff: runAff, 
        nonCanceler: nonCanceler, 
        launchAff: launchAff, 
        "later'": later$prime, 
        later: later, 
        forkAff: forkAff, 
        cancelWith: cancelWith, 
        cancel: cancel, 
        attempt: attempt, 
        apathize: apathize, 
        functorAff: functorAff, 
        applyAff: applyAff, 
        applicativeAff: applicativeAff, 
        bindAff: bindAff, 
        monadAff: monadAff, 
        monadEffAff: monadEffAff, 
        monadErrorAff: monadErrorAff, 
        semigroupCanceler: semigroupCanceler
    };
})();
var PS = PS || {};
PS.Control_Monad_Aff_AVar = (function () {
    "use strict";
    var Control_Monad_Aff = PS.Control_Monad_Aff;
    var Prelude = PS.Prelude;
    var Data_Function = PS.Data_Function;
    var Control_Monad_Eff_Exception = PS.Control_Monad_Eff_Exception;
    
    function _makeVar(nonCanceler) {
      return function(success, error) {
        try {
          success({
            consumers: [],
            producers: [],
            error: undefined 
          });
        } catch (e) {
          error(e);
        }

        return nonCanceler;
      }
    }
  ;
    
    function _takeVar(nonCanceler, avar) {
      return function(success, error) {
        if (avar.error !== undefined) {
          error(avar.error);
        } else if (avar.producers.length > 0) {
          var producer = avar.producers.shift();

          producer(success, error);
        } else {
          avar.consumers.push({success: success, error: error});
        }

        return nonCanceler;
      } 
    }
  ;
    
    function _putVar(nonCanceler, avar, a) {
      return function(success, error) {
        if (avar.error !== undefined) {
          error(avar.error);
        } else if (avar.consumers.length === 0) {
          avar.producers.push(function(success, error) {
            try {
              success(a);
            } catch (e) {
              error(e);
            }
          });

          success({});
        } else {
          var consumer = avar.consumers.shift();

          try {
            consumer.success(a);
          } catch (e) {
            error(e);

            return;                  
          }

          success({});
        }

        return nonCanceler;
      }
    }
  ;
    
    function _killVar(nonCanceler, avar, e) {
      return function(success, error) {
        if (avar.error !== undefined) {
          error(avar.error);
        } else {
          var errors = [];

          avar.error = e;

          while (avar.consumers.length > 0) {
            var consumer = avar.consumers.shift();

            try {
              consumer.error(e);
            } catch (e) {
              errors.push(e);              
            }
          }

          if (errors.length > 0) error(errors[0]);
          else success({});
        }

        return nonCanceler;
      }
    }
  ;
    
    /**
     *  | Takes the next value from the asynchronous avar.
     */
    var takeVar = function (q) {
        return _takeVar(Control_Monad_Aff.nonCanceler, q);
    };
    
    /**
     *  | Puts a new value into the asynchronous avar. If the avar has
     *  | been killed, this will result in an error.
     */
    var putVar = function (q) {
        return function (a) {
            return _putVar(Control_Monad_Aff.nonCanceler, q, a);
        };
    };
    
    /**
     *  | Makes a new asynchronous avar.
     */
    var makeVar = _makeVar(Control_Monad_Aff.nonCanceler);
    
    /**
     *  | Makes a avar and sets it to some value.
     */
    var makeVar$prime = function (a) {
        return Prelude[">>="](Control_Monad_Aff.bindAff)(makeVar)(function (_24) {
            return Prelude[">>="](Control_Monad_Aff.bindAff)(putVar(_24)(a))(function () {
                return Prelude["return"](Control_Monad_Aff.monadAff)(_24);
            });
        });
    };
    
    /**
     *  | Kills an asynchronous avar.
     */
    var killVar = function (q) {
        return function (e) {
            return _killVar(Control_Monad_Aff.nonCanceler, q, e);
        };
    };
    return {
        takeVar: takeVar, 
        putVar: putVar, 
        "makeVar'": makeVar$prime, 
        makeVar: makeVar, 
        killVar: killVar
    };
})();
var PS = PS || {};
PS.Control_Monad_Aff_Debug_Trace = (function () {
    "use strict";
    var Prelude = PS.Prelude;
    var Control_Monad_Eff_Class = PS.Control_Monad_Eff_Class;
    var Debug_Trace = PS.Debug_Trace;
    var Control_Monad_Aff = PS.Control_Monad_Aff;
    
    /**
     *  | Traces any `Show`-able value to the console. This basically saves you 
     *  | from writing `liftEff $ trace x` everywhere.
     */
    var trace = function (__dict_Show_266) {
        return function (a) {
            return Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Eff_Class.liftEff(Control_Monad_Aff.monadEffAff)(Debug_Trace.trace(Prelude.show(__dict_Show_266)(a))))(function () {
                return Prelude["return"](Control_Monad_Aff.monadAff)(a);
            });
        };
    };
    return {
        trace: trace
    };
})();
var PS = PS || {};
PS.Control_Monad_Aff_Par = (function () {
    "use strict";
    var Prelude = PS.Prelude;
    var Data_Monoid = PS.Data_Monoid;
    var Control_Monad_Aff_AVar = PS.Control_Monad_Aff_AVar;
    var Control_Monad_Aff = PS.Control_Monad_Aff;
    var Data_Either = PS.Data_Either;
    var Control_Plus = PS.Control_Plus;
    var Control_Apply = PS.Control_Apply;
    var Control_Alt = PS.Control_Alt;
    var Control_Alternative = PS.Control_Alternative;
    var Control_Monad_Error_Class = PS.Control_Monad_Error_Class;
    var Par = function (x) {
        return x;
    };
    
    /**
     *  | Extracts the `Aff` from the `Par`.
     */
    var runPar = function (_311) {
        return _311;
    };
    var functorPar = new Prelude.Functor(function (_312) {
        return function (_313) {
            return Prelude["<$>"](Control_Monad_Aff.functorAff)(_312)(_313);
        };
    });
    
    /**
     *  | Returns the first value, or the first error if both error.
     */
    var altPar = new Control_Alt.Alt(function (_316) {
        return function (_317) {
            var maybeKill = function (va) {
                return function (ve) {
                    return function (err) {
                        return Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff_AVar.takeVar(ve))(function (_29) {
                            return Prelude[">>="](Control_Monad_Aff.bindAff)((function () {
                                var _509 = _29 === 1;
                                if (_509) {
                                    return Control_Monad_Aff_AVar.killVar(va)(err);
                                };
                                if (!_509) {
                                    return Prelude["return"](Control_Monad_Aff.monadAff)(Prelude.unit);
                                };
                                throw new Error("Failed pattern match");
                            })())(function () {
                                return Control_Monad_Aff_AVar.putVar(ve)(_29 + 1);
                            });
                        });
                    };
                };
            };
            return Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff_AVar.makeVar)(function (_33) {
                return Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff_AVar["makeVar'"](0))(function (_32) {
                    return Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff.forkAff(Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff.attempt(_316))(Data_Either.either(maybeKill(_33)(_32))(Control_Monad_Aff_AVar.putVar(_33)))))(function (_31) {
                        return Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff.forkAff(Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff.attempt(_317))(Data_Either.either(maybeKill(_33)(_32))(Control_Monad_Aff_AVar.putVar(_33)))))(function (_30) {
                            return Control_Monad_Aff.cancelWith(Control_Monad_Aff_AVar.takeVar(_33))(Prelude["<>"](Control_Monad_Aff.semigroupCanceler)(_31)(_30));
                        });
                    });
                });
            });
        };
    }, function () {
        return functorPar;
    });
    return {
        Par: Par, 
        runPar: runPar, 
        functorPar: functorPar, 
        altPar: altPar
    };
})();
var PS = PS || {};
PS.Examples = (function () {
    "use strict";
    var Control_Monad_Aff_Debug_Trace = PS.Control_Monad_Aff_Debug_Trace;
    var Prelude = PS.Prelude;
    var Control_Monad_Aff = PS.Control_Monad_Aff;
    var Control_Monad_Error_Class = PS.Control_Monad_Error_Class;
    var Control_Monad_Eff_Exception = PS.Control_Monad_Eff_Exception;
    var Data_Either = PS.Data_Either;
    var Control_Monad_Aff_AVar = PS.Control_Monad_Aff_AVar;
    var Control_Monad_Aff_Par = PS.Control_Monad_Aff_Par;
    var Control_Alt = PS.Control_Alt;
    var Debug_Trace = PS.Debug_Trace;
    var Control_Apply = PS.Control_Apply;
    var Control_Monad_Eff_Class = PS.Control_Monad_Eff_Class;
    var test_sequencing = function (_487) {
        if (_487 === 0) {
            return Control_Monad_Aff_Debug_Trace.trace(Prelude.showString)("Done");
        };
        return Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff["later'"](100)(Control_Monad_Aff_Debug_Trace.trace(Prelude.showString)(Prelude.show(Prelude.showNumber)(_487 / 10) + " seconds left")))(function () {
            return test_sequencing(_487 - 1);
        });
    };
    var test_semigroupCanceler = (function () {
        var c = Prelude["<>"](Control_Monad_Aff.semigroupCanceler)(Prelude["const"](Prelude.pure(Control_Monad_Aff.applicativeAff)(true)))(Prelude["const"](Prelude.pure(Control_Monad_Aff.applicativeAff)(true)));
        return Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff.cancel(c)(Control_Monad_Eff_Exception.error("CANCEL")))(function (_48) {
            return Control_Monad_Aff_Debug_Trace.trace(Prelude.showString)((function () {
                if (_48) {
                    return "Success: Canceled semigroup composite canceler";
                };
                if (!_48) {
                    return "Failure: Could not cancel semigroup composite canceler";
                };
                throw new Error("Failed pattern match");
            })());
        });
    })();
    var test_putTakeVar = Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff_AVar.makeVar)(function (_40) {
        return Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff.forkAff(Control_Monad_Aff.later(Control_Monad_Aff_AVar.putVar(_40)(1.0))))(function () {
            return Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff_AVar.takeVar(_40))(function (_39) {
                return Control_Monad_Aff_Debug_Trace.trace(Prelude.showString)("Success: Value " + Prelude.show(Prelude.showNumber)(_39));
            });
        });
    });
    var test_pure = Prelude[">>="](Control_Monad_Aff.bindAff)(Prelude.pure(Control_Monad_Aff.applicativeAff)(Prelude.unit))(function () {
        return Prelude[">>="](Control_Monad_Aff.bindAff)(Prelude.pure(Control_Monad_Aff.applicativeAff)(Prelude.unit))(function () {
            return Prelude[">>="](Control_Monad_Aff.bindAff)(Prelude.pure(Control_Monad_Aff.applicativeAff)(Prelude.unit))(function () {
                return Control_Monad_Aff_Debug_Trace.trace(Prelude.showString)("Success: Got all the way past 4 pures");
            });
        });
    });
    var test_parRaceKill2 = Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff.attempt(Control_Monad_Aff_Par.runPar(Control_Alt["<|>"](Control_Monad_Aff_Par.altPar)(Control_Monad_Aff["later'"](100)(Control_Monad_Error_Class.throwError(Control_Monad_Aff.monadErrorAff)(Control_Monad_Eff_Exception.error("Oh noes!"))))(Control_Monad_Aff["later'"](200)(Control_Monad_Error_Class.throwError(Control_Monad_Aff.monadErrorAff)(Control_Monad_Eff_Exception.error("Oh noes!")))))))(function (_47) {
        return Data_Either.either(Prelude["const"](Control_Monad_Aff_Debug_Trace.trace(Prelude.showString)("Success: Killing both kills it dead")))(Prelude["const"](Control_Monad_Aff_Debug_Trace.trace(Prelude.showString)("Failure: It's alive!!!")))(_47);
    });
    var test_parRaceKill1 = Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff_Par.runPar(Control_Alt["<|>"](Control_Monad_Aff_Par.altPar)(Control_Monad_Aff["later'"](100)(Control_Monad_Error_Class.throwError(Control_Monad_Aff.monadErrorAff)(Control_Monad_Eff_Exception.error("Oh noes!"))))(Control_Monad_Aff["later'"](200)(Prelude.pure(Control_Monad_Aff.applicativeAff)("Success: Early error was ignored in favor of late success")))))(function (_46) {
        return Control_Monad_Aff_Debug_Trace.trace(Prelude.showString)(_46);
    });
    var test_parRace = Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff_Par.runPar(Control_Alt["<|>"](Control_Monad_Aff_Par.altPar)(Control_Monad_Aff["later'"](100)(Prelude.pure(Control_Monad_Aff.applicativeAff)("Success: Early bird got the worm")))(Control_Monad_Aff["later'"](200)(Prelude.pure(Control_Monad_Aff.applicativeAff)("Failure: Late bird got the worm")))))(function (_45) {
        return Control_Monad_Aff_Debug_Trace.trace(Prelude.showString)(_45);
    });
    var test_killVar = Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff_AVar.makeVar)(function (_44) {
        return Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff_AVar.killVar(_44)(Control_Monad_Eff_Exception.error("DOA")))(function () {
            return Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff.attempt(Control_Monad_Aff_AVar.takeVar(_44)))(function (_43) {
                return Data_Either.either(Prelude["const"](Control_Monad_Aff_Debug_Trace.trace(Prelude.showString)("Success: Killed queue dead")))(Prelude["const"](Control_Monad_Aff_Debug_Trace.trace(Prelude.showString)("Failure: Oh noes, queue survived!")))(_43);
            });
        });
    });
    var test_killFirstForked = Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff.forkAff(Control_Monad_Aff["later'"](100)(Prelude.pure(Control_Monad_Aff.applicativeAff)("Failure: This should have been killed!"))))(function (_42) {
        return Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff.cancel(_42)(Control_Monad_Eff_Exception.error("Just die")))(function (_41) {
            return Control_Monad_Aff_Debug_Trace.trace(Prelude.showString)((function () {
                if (_41) {
                    return "Success: Killed first forked";
                };
                if (!_41) {
                    return "Failure: Couldn't kill first forked";
                };
                throw new Error("Failed pattern match");
            })());
        });
    });
    var test_cancelPar = Prelude[">>="](Control_Monad_Aff.bindAff)(Prelude["<<<"](Prelude.semigroupoidArr)(Control_Monad_Aff.forkAff)(Control_Monad_Aff_Par.runPar)(Control_Alt["<|>"](Control_Monad_Aff_Par.altPar)(Control_Monad_Aff["later'"](100)(Control_Monad_Aff_Debug_Trace.trace(Prelude.showString)("Failure: #1 should not get through")))(Control_Monad_Aff["later'"](100)(Control_Monad_Aff_Debug_Trace.trace(Prelude.showString)("Failure: #2 should not get through")))))(function (_53) {
        return Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff.cancel(_53)(Control_Monad_Eff_Exception.error("Must cancel")))(function (_52) {
            return Control_Monad_Aff_Debug_Trace.trace(Prelude.showString)((function () {
                if (_52) {
                    return "Success: Canceling composite of two Par succeeded";
                };
                if (!_52) {
                    return "Failure: Canceling composite of two Par failed";
                };
                throw new Error("Failed pattern match");
            })());
        });
    });
    var test_cancelLater = Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff.forkAff(Prelude[">>="](Control_Monad_Aff.bindAff)(Prelude.pure(Control_Monad_Aff.applicativeAff)("Binding"))(function () {
        return Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff["later'"](100)(Control_Monad_Aff_Debug_Trace.trace(Prelude.showString)("Failure: Later was not canceled!")))(function (_49) {
            return Prelude.pure(Control_Monad_Aff.applicativeAff)("Binding");
        });
    })))(function (_51) {
        return Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff.cancel(_51)(Control_Monad_Eff_Exception.error("Cause")))(function (_50) {
            return Control_Monad_Aff_Debug_Trace.trace(Prelude.showString)((function () {
                if (_50) {
                    return "Success: Canceled later";
                };
                if (!_50) {
                    return "Failure: Did not cancel later";
                };
                throw new Error("Failed pattern match");
            })());
        });
    });
    var test_attempt = Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff.attempt(Control_Monad_Error_Class.throwError(Control_Monad_Aff.monadErrorAff)(Control_Monad_Eff_Exception.error("Oh noes!"))))(function (_38) {
        return Data_Either.either(Prelude["const"](Control_Monad_Aff_Debug_Trace.trace(Prelude.showString)("Success: Exception caught")))(Prelude["const"](Control_Monad_Aff_Debug_Trace.trace(Prelude.showString)("Failure: Exception NOT caught!!!")))(_38);
    });
    var test_apathize = Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff.apathize(Control_Monad_Error_Class.throwError(Control_Monad_Aff.monadErrorAff)(Control_Monad_Eff_Exception.error("Oh noes!"))))(function () {
        return Control_Monad_Aff_Debug_Trace.trace(Prelude.showString)("Success: Exceptions don't stop the apathetic");
    });
    var main = Control_Monad_Aff.launchAff(Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff_Debug_Trace.trace(Prelude.showString)("Testing sequencing"))(function () {
        return Prelude[">>="](Control_Monad_Aff.bindAff)(test_sequencing(3))(function () {
            return Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff_Debug_Trace.trace(Prelude.showString)("Testing pure"))(function () {
                return Prelude[">>="](Control_Monad_Aff.bindAff)(test_pure)(function () {
                    return Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff_Debug_Trace.trace(Prelude.showString)("Testing attempt"))(function () {
                        return Prelude[">>="](Control_Monad_Aff.bindAff)(test_attempt)(function () {
                            return Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff_Debug_Trace.trace(Prelude.showString)("Testing later"))(function () {
                                return Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff.later(Control_Monad_Aff_Debug_Trace.trace(Prelude.showString)("Success: It happened later")))(function () {
                                    return Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff_Debug_Trace.trace(Prelude.showString)("Testing kill of later"))(function () {
                                        return Prelude[">>="](Control_Monad_Aff.bindAff)(test_cancelLater)(function () {
                                            return Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff_Debug_Trace.trace(Prelude.showString)("Testing kill of first forked"))(function () {
                                                return Prelude[">>="](Control_Monad_Aff.bindAff)(test_killFirstForked)(function () {
                                                    return Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff_Debug_Trace.trace(Prelude.showString)("Testing apathize"))(function () {
                                                        return Prelude[">>="](Control_Monad_Aff.bindAff)(test_apathize)(function () {
                                                            return Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff_Debug_Trace.trace(Prelude.showString)("Testing semigroup canceler"))(function () {
                                                                return Prelude[">>="](Control_Monad_Aff.bindAff)(test_semigroupCanceler)(function () {
                                                                    return Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff_Debug_Trace.trace(Prelude.showString)("Testing AVar - putVar, takeVar"))(function () {
                                                                        return Prelude[">>="](Control_Monad_Aff.bindAff)(test_putTakeVar)(function () {
                                                                            return Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff_Debug_Trace.trace(Prelude.showString)("Testing AVar killVar"))(function () {
                                                                                return Prelude[">>="](Control_Monad_Aff.bindAff)(test_killVar)(function () {
                                                                                    return Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff_Debug_Trace.trace(Prelude.showString)("Testing Par (<|>)"))(function () {
                                                                                        return Prelude[">>="](Control_Monad_Aff.bindAff)(test_parRace)(function () {
                                                                                            return Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff_Debug_Trace.trace(Prelude.showString)("Testing Par (<|>) - kill one"))(function () {
                                                                                                return Prelude[">>="](Control_Monad_Aff.bindAff)(test_parRaceKill1)(function () {
                                                                                                    return Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff_Debug_Trace.trace(Prelude.showString)("Testing Par (<|>) - kill two"))(function () {
                                                                                                        return Prelude[">>="](Control_Monad_Aff.bindAff)(test_parRaceKill2)(function () {
                                                                                                            return Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff_Debug_Trace.trace(Prelude.showString)("Testing cancel of Par (<|>)"))(function () {
                                                                                                                return Prelude[">>="](Control_Monad_Aff.bindAff)(test_cancelPar)(function () {
                                                                                                                    return Control_Monad_Aff_Debug_Trace.trace(Prelude.showString)("Done testing");
                                                                                                                });
                                                                                                            });
                                                                                                        });
                                                                                                    });
                                                                                                });
                                                                                            });
                                                                                        });
                                                                                    });
                                                                                });
                                                                            });
                                                                        });
                                                                    });
                                                                });
                                                            });
                                                        });
                                                    });
                                                });
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    }));
    return {
        main: main, 
        test_cancelPar: test_cancelPar, 
        test_cancelLater: test_cancelLater, 
        test_semigroupCanceler: test_semigroupCanceler, 
        test_parRaceKill2: test_parRaceKill2, 
        test_parRaceKill1: test_parRaceKill1, 
        test_parRace: test_parRace, 
        test_killVar: test_killVar, 
        test_killFirstForked: test_killFirstForked, 
        test_putTakeVar: test_putTakeVar, 
        test_apathize: test_apathize, 
        test_attempt: test_attempt, 
        test_pure: test_pure, 
        test_sequencing: test_sequencing
    };
})();
PS.Examples.main();
