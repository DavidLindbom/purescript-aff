// Generated by psc version 0.6.8
var PS = PS || {};
PS.Prelude = (function () {
    "use strict";
    
    function showNumberImpl(n) {
      return n.toString();
    }
    ;
    
    function numAdd(n1) {
      return function(n2) {
        return n1 + n2;
      };
    }
    ;
    
    function numSub(n1) {
      return function(n2) {
        return n1 - n2;
      };
    }
    ;
    
    function numMul(n1) {
      return function(n2) {
        return n1 * n2;
      };
    }
    ;
    
    function concatString(s1) {
      return function(s2) {
        return s1 + s2;
      };
    }
    ;
    var Unit = function (x) {
        return x;
    };
    var Show = function (show) {
        this.show = show;
    };
    var Functor = function ($less$dollar$greater) {
        this["<$>"] = $less$dollar$greater;
    };
    var Apply = function ($less$times$greater, __superclass_Prelude$dotFunctor_0) {
        this["<*>"] = $less$times$greater;
        this["__superclass_Prelude.Functor_0"] = __superclass_Prelude$dotFunctor_0;
    };
    var Applicative = function (__superclass_Prelude$dotApply_0, pure) {
        this["__superclass_Prelude.Apply_0"] = __superclass_Prelude$dotApply_0;
        this.pure = pure;
    };
    var Bind = function ($greater$greater$eq, __superclass_Prelude$dotApply_0) {
        this[">>="] = $greater$greater$eq;
        this["__superclass_Prelude.Apply_0"] = __superclass_Prelude$dotApply_0;
    };
    var Monad = function (__superclass_Prelude$dotApplicative_0, __superclass_Prelude$dotBind_1) {
        this["__superclass_Prelude.Applicative_0"] = __superclass_Prelude$dotApplicative_0;
        this["__superclass_Prelude.Bind_1"] = __superclass_Prelude$dotBind_1;
    };
    
    /**
     *  | Addition and multiplication
     */
    var Semiring = function ($times, $plus, one, zero) {
        this["*"] = $times;
        this["+"] = $plus;
        this.one = one;
        this.zero = zero;
    };
    
    /**
     *  | Addition, multiplication, and subtraction
     */
    var Ring = function ($minus, __superclass_Prelude$dotSemiring_0) {
        this["-"] = $minus;
        this["__superclass_Prelude.Semiring_0"] = __superclass_Prelude$dotSemiring_0;
    };
    var Semigroup = function ($less$greater) {
        this["<>"] = $less$greater;
    };
    var $greater$greater$eq = function (dict) {
        return dict[">>="];
    };
    var $less$greater = function (dict) {
        return dict["<>"];
    };
    var $less$times$greater = function (dict) {
        return dict["<*>"];
    };
    
    /**
     *  | Addition, multiplication, and subtraction
     */
    var $minus = function (dict) {
        return dict["-"];
    };
    var $plus$plus = function (__dict_Semigroup_2) {
        return $less$greater(__dict_Semigroup_2);
    };
    var $dollar = function (f) {
        return function (x) {
            return f(x);
        };
    };
    var unit = {};
    var showNumber = new Show(showNumberImpl);
    var show = function (dict) {
        return dict.show;
    };
    var semiringNumber = new Semiring(numMul, numAdd, 1, 0);
    var semigroupString = new Semigroup(concatString);
    var ringNumber = new Ring(numSub, function () {
        return semiringNumber;
    });
    var pure = function (dict) {
        return dict.pure;
    };
    var $$return = function (__dict_Monad_5) {
        return pure(__dict_Monad_5["__superclass_Prelude.Applicative_0"]());
    };
    var liftA1 = function (__dict_Applicative_8) {
        return function (f) {
            return function (a) {
                return $less$times$greater(__dict_Applicative_8["__superclass_Prelude.Apply_0"]())(pure(__dict_Applicative_8)(f))(a);
            };
        };
    };
    
    /**
     *  | Returns its first argument and ignores its second.
     */
    var $$const = function (_25) {
        return function (_26) {
            return _25;
        };
    };
    var ap = function (__dict_Monad_16) {
        return function (f) {
            return function (a) {
                return $greater$greater$eq(__dict_Monad_16["__superclass_Prelude.Bind_1"]())(f)(function (_2) {
                    return $greater$greater$eq(__dict_Monad_16["__superclass_Prelude.Bind_1"]())(a)(function (_1) {
                        return $$return(__dict_Monad_16)(_2(_1));
                    });
                });
            };
        };
    };
    return {
        Unit: Unit, 
        Semigroup: Semigroup, 
        Ring: Ring, 
        Semiring: Semiring, 
        Monad: Monad, 
        Bind: Bind, 
        Applicative: Applicative, 
        Apply: Apply, 
        Functor: Functor, 
        Show: Show, 
        unit: unit, 
        "++": $plus$plus, 
        "<>": $less$greater, 
        "-": $minus, 
        ap: ap, 
        "return": $$return, 
        ">>=": $greater$greater$eq, 
        liftA1: liftA1, 
        pure: pure, 
        "<*>": $less$times$greater, 
        show: show, 
        "$": $dollar, 
        "const": $$const, 
        showNumber: showNumber, 
        semiringNumber: semiringNumber, 
        ringNumber: ringNumber, 
        semigroupString: semigroupString
    };
})();
var PS = PS || {};
PS.Control_Monad_Eff = (function () {
    "use strict";
    var Prelude = PS.Prelude;
    
    function returnE(a) {
      return function() {
        return a;
      };
    }
    ;
    
    function bindE(a) {
      return function(f) {
        return function() {
          return f(a())();
        };
      };
    }
    ;
    var monadEff = new Prelude.Monad(function () {
        return applicativeEff;
    }, function () {
        return bindEff;
    });
    var bindEff = new Prelude.Bind(bindE, function () {
        return applyEff;
    });
    var applyEff = new Prelude.Apply(Prelude.ap(monadEff), function () {
        return functorEff;
    });
    var applicativeEff = new Prelude.Applicative(function () {
        return applyEff;
    }, returnE);
    var functorEff = new Prelude.Functor(Prelude.liftA1(applicativeEff));
    return {
        bindE: bindE, 
        returnE: returnE, 
        functorEff: functorEff, 
        applyEff: applyEff, 
        applicativeEff: applicativeEff, 
        bindEff: bindEff, 
        monadEff: monadEff
    };
})();
var PS = PS || {};
PS.Control_Monad_Eff_Unsafe = (function () {
    "use strict";
    var Prelude = PS.Prelude;
    var Control_Monad_Eff = PS.Control_Monad_Eff;
    
    function unsafeInterleaveEff(f) {
      return f;
    }
    ;
    return {
        unsafeInterleaveEff: unsafeInterleaveEff
    };
})();
var PS = PS || {};
PS.Debug_Trace = (function () {
    "use strict";
    var Prelude = PS.Prelude;
    var Control_Monad_Eff = PS.Control_Monad_Eff;
    
    function trace(s) {
      return function() {
        console.log(s);
        return {};
      };
    }
    ;
    return {
        trace: trace
    };
})();
var PS = PS || {};
PS.Control_Monad_Eff_Class = (function () {
    "use strict";
    var Prelude = PS.Prelude;
    var Control_Monad_Trans = PS.Control_Monad_Trans;
    var Data_Monoid = PS.Data_Monoid;
    var Control_Monad_Eff = PS.Control_Monad_Eff;
    var Control_Monad_Maybe_Trans = PS.Control_Monad_Maybe_Trans;
    var Control_Monad_Error_Trans = PS.Control_Monad_Error_Trans;
    var Control_Monad_State_Trans = PS.Control_Monad_State_Trans;
    var Control_Monad_Writer_Trans = PS.Control_Monad_Writer_Trans;
    var Control_Monad_Reader_Trans = PS.Control_Monad_Reader_Trans;
    var Control_Monad_RWS_Trans = PS.Control_Monad_RWS_Trans;
    
    /**
     *  | The `MonadEff` class captures those monads which support native effects.
     *  |
     *  | Instances are provided for `Eff` itself, and the standard monad transformers.
     *  |
     *  | `liftEff` can be used in any appropriate monad transformer stack to lift an action
     *  | of type `Eff eff a` into the monad.
     *  |
     *  | Note that `MonadEff` is parameterized by the row of effects, so type inference can be
     *  | tricky. It is generally recommended to either work with a polymorphic row of effects,
     *  | or a concrete, closed row of effects such as `(trace :: Trace)`.
     */
    var MonadEff = function (__superclass_Prelude$dotMonad_0, liftEff) {
        this["__superclass_Prelude.Monad_0"] = __superclass_Prelude$dotMonad_0;
        this.liftEff = liftEff;
    };
    
    /**
     *  | The `MonadEff` class captures those monads which support native effects.
     *  |
     *  | Instances are provided for `Eff` itself, and the standard monad transformers.
     *  |
     *  | `liftEff` can be used in any appropriate monad transformer stack to lift an action
     *  | of type `Eff eff a` into the monad.
     *  |
     *  | Note that `MonadEff` is parameterized by the row of effects, so type inference can be
     *  | tricky. It is generally recommended to either work with a polymorphic row of effects,
     *  | or a concrete, closed row of effects such as `(trace :: Trace)`.
     */
    var liftEff = function (dict) {
        return dict.liftEff;
    };
    return {
        MonadEff: MonadEff, 
        liftEff: liftEff
    };
})();
var PS = PS || {};
PS.Control_Monad_Aff = (function () {
    "use strict";
    var Prelude = PS.Prelude;
    var Control_Monad_Eff_Unsafe = PS.Control_Monad_Eff_Unsafe;
    var Control_Monad_Eff_Exception = PS.Control_Monad_Eff_Exception;
    var Data_Monoid = PS.Data_Monoid;
    var Data_Either = PS.Data_Either;
    var Control_Monad_Error_Class = PS.Control_Monad_Error_Class;
    var Control_Apply = PS.Control_Apply;
    var Control_Alt = PS.Control_Alt;
    var Control_Plus = PS.Control_Plus;
    var Control_Alternative = PS.Control_Alternative;
    var Control_MonadPlus = PS.Control_MonadPlus;
    var Control_Monad_Eff = PS.Control_Monad_Eff;
    var Control_Monad_Eff_Class = PS.Control_Monad_Eff_Class;
    
    /**
     *  | A computation with effects `e`. The computation either errors or 
     *  | produces a value of type `a`.
     *  |
     *  | This is moral equivalent of `ErrorT (ContT Unit (EffA e)) a`.
     */
    var Aff = function (x) {
        return x;
    };
    
    /**
     *  | Runs the asynchronous computation. You must supply an error callback and a 
     *  | success callback.
     */
    var runAff = function (_280) {
        return function (_281) {
            return function (_282) {
                return _282(_280)(_281);
            };
        };
    };
    
    /**
     *  | Converts the asynchronous computation into a synchronous one. All values 
     *  | and errors are ignored.
     */
    var launchAff = function (_279) {
        return _279(Prelude["const"](Prelude.pure(Control_Monad_Eff.applicativeEff)(Prelude.unit)))(Prelude["const"](Prelude.pure(Control_Monad_Eff.applicativeEff)(Prelude.unit)));
    };
    var functorAff = new Prelude.Functor(function (_284) {
        return function (_285) {
            return function (ex) {
                return function (h) {
                    return _285(ex)(function (a) {
                        return h(_284(a));
                    });
                };
            };
        };
    });
    var applyAff = new Prelude.Apply(function (_286) {
        return function (_287) {
            return function (ex) {
                return function (h) {
                    return _286(ex)(function (f) {
                        return Control_Monad_Eff_Unsafe.unsafeInterleaveEff(_287(ex)(function (a) {
                            return h(f(a));
                        }));
                    });
                };
            };
        };
    }, function () {
        return functorAff;
    });
    var bindAff = new Prelude.Bind(function (_288) {
        return function (_289) {
            return function (ex) {
                return function (h) {
                    return _288(ex)(function (a) {
                        return Control_Monad_Eff_Unsafe.unsafeInterleaveEff(runAff(ex)(function (b) {
                            return h(b);
                        })(_289(a)));
                    });
                };
            };
        };
    }, function () {
        return applyAff;
    });
    var applicativeAff = new Prelude.Applicative(function () {
        return applyAff;
    }, function (v) {
        return function (_276) {
            return function (h) {
                return Control_Monad_Eff_Unsafe.unsafeInterleaveEff(h(v));
            };
        };
    });
    var monadAff = new Prelude.Monad(function () {
        return applicativeAff;
    }, function () {
        return bindAff;
    });
    var monadEffAff = new Control_Monad_Eff_Class.MonadEff(function () {
        return monadAff;
    }, function (fa) {
        return function (_277) {
            return function (h) {
                return Control_Monad_Eff_Unsafe.unsafeInterleaveEff(Prelude[">>="](Control_Monad_Eff.bindEff)(Control_Monad_Eff_Unsafe.unsafeInterleaveEff(fa))(h));
            };
        };
    });
    return {
        runAff: runAff, 
        launchAff: launchAff, 
        functorAff: functorAff, 
        applyAff: applyAff, 
        applicativeAff: applicativeAff, 
        bindAff: bindAff, 
        monadAff: monadAff, 
        monadEffAff: monadEffAff
    };
})();
var PS = PS || {};
PS.Examples = (function () {
    "use strict";
    var Prelude = PS.Prelude;
    var Control_Monad_Eff_Class = PS.Control_Monad_Eff_Class;
    var Debug_Trace = PS.Debug_Trace;
    var Control_Monad_Aff = PS.Control_Monad_Aff;
    
    function timeout(time) {
      return function(error) {
        return function(success) {
          return function() {
            setTimeout(function() {
              try {
                success({})();
              } catch (e) {
                error(e)();
              }
            }, time);
          }
        }
      }
    }
  ;
    var test_sequencing = function (_290) {
        if (_290 === 0) {
            return Control_Monad_Eff_Class.liftEff(Control_Monad_Aff.monadEffAff)(Debug_Trace.trace("Done"));
        };
        return Prelude[">>="](Control_Monad_Aff.bindAff)(timeout(1000))(function () {
            return Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Eff_Class.liftEff(Control_Monad_Aff.monadEffAff)(Debug_Trace.trace(Prelude.show(Prelude.showNumber)(_290) + " seconds left")))(function () {
                return test_sequencing(_290 - 1);
            });
        });
    };
    var main = Control_Monad_Aff.launchAff(Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Eff_Class.liftEff(Control_Monad_Aff.monadEffAff)(Debug_Trace.trace("Testing sequencing")))(function () {
        return test_sequencing(10);
    }));
    return {
        main: main, 
        test_sequencing: test_sequencing, 
        timeout: timeout
    };
})();
PS.Examples.main();
