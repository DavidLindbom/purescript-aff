// Generated by psc version 0.6.8
var PS = PS || {};
PS.Prelude = (function () {
    "use strict";
    
    function showNumberImpl(n) {
      return n.toString();
    }
    ;
    
    function numAdd(n1) {
      return function(n2) {
        return n1 + n2;
      };
    }
    ;
    
    function numSub(n1) {
      return function(n2) {
        return n1 - n2;
      };
    }
    ;
    
    function numMul(n1) {
      return function(n2) {
        return n1 * n2;
      };
    }
    ;
    
    function numDiv(n1) {
      return function(n2) {
        return n1 / n2;
      };
    }
    ;
    
    function refEq(r1) {
      return function(r2) {
        return r1 === r2;
      };
    }
    ;
    
    function refIneq(r1) {
      return function(r2) {
        return r1 !== r2;
      };
    }
    ;
    
    function concatString(s1) {
      return function(s2) {
        return s1 + s2;
      };
    }
    ;
    var Unit = function (x) {
        return x;
    };
    var Show = function (show) {
        this.show = show;
    };
    var Functor = function ($less$dollar$greater) {
        this["<$>"] = $less$dollar$greater;
    };
    var Apply = function ($less$times$greater, __superclass_Prelude$dotFunctor_0) {
        this["<*>"] = $less$times$greater;
        this["__superclass_Prelude.Functor_0"] = __superclass_Prelude$dotFunctor_0;
    };
    var Applicative = function (__superclass_Prelude$dotApply_0, pure) {
        this["__superclass_Prelude.Apply_0"] = __superclass_Prelude$dotApply_0;
        this.pure = pure;
    };
    var Bind = function ($greater$greater$eq, __superclass_Prelude$dotApply_0) {
        this[">>="] = $greater$greater$eq;
        this["__superclass_Prelude.Apply_0"] = __superclass_Prelude$dotApply_0;
    };
    var Monad = function (__superclass_Prelude$dotApplicative_0, __superclass_Prelude$dotBind_1) {
        this["__superclass_Prelude.Applicative_0"] = __superclass_Prelude$dotApplicative_0;
        this["__superclass_Prelude.Bind_1"] = __superclass_Prelude$dotBind_1;
    };
    
    /**
     *  | Addition and multiplication
     */
    var Semiring = function ($times, $plus, one, zero) {
        this["*"] = $times;
        this["+"] = $plus;
        this.one = one;
        this.zero = zero;
    };
    
    /**
     *  | Semiring with modulo operation and division where
     *  | ```a / b * b + (a `mod` b) = a```
     */
    var ModuloSemiring = function ($div, __superclass_Prelude$dotSemiring_0, mod) {
        this["/"] = $div;
        this["__superclass_Prelude.Semiring_0"] = __superclass_Prelude$dotSemiring_0;
        this.mod = mod;
    };
    
    /**
     *  | Addition, multiplication, and subtraction
     */
    var Ring = function ($minus, __superclass_Prelude$dotSemiring_0) {
        this["-"] = $minus;
        this["__superclass_Prelude.Semiring_0"] = __superclass_Prelude$dotSemiring_0;
    };
    var Eq = function ($div$eq, $eq$eq) {
        this["/="] = $div$eq;
        this["=="] = $eq$eq;
    };
    var Semigroup = function ($less$greater) {
        this["<>"] = $less$greater;
    };
    var $greater$greater$eq = function (dict) {
        return dict[">>="];
    };
    var $eq$eq = function (dict) {
        return dict["=="];
    };
    var $less$greater = function (dict) {
        return dict["<>"];
    };
    var $less$times$greater = function (dict) {
        return dict["<*>"];
    };
    var $less$dollar$greater = function (dict) {
        return dict["<$>"];
    };
    
    /**
     *  | Semiring with modulo operation and division where
     *  | ```a / b * b + (a `mod` b) = a```
     */
    var $div = function (dict) {
        return dict["/"];
    };
    
    /**
     *  | Addition, multiplication, and subtraction
     */
    var $minus = function (dict) {
        return dict["-"];
    };
    var $plus$plus = function (__dict_Semigroup_2) {
        return $less$greater(__dict_Semigroup_2);
    };
    
    /**
     *  | Addition and multiplication
     */
    var $plus = function (dict) {
        return dict["+"];
    };
    var $dollar = function (f) {
        return function (x) {
            return f(x);
        };
    };
    var unit = {};
    var showNumber = new Show(showNumberImpl);
    var show = function (dict) {
        return dict.show;
    };
    var semiringNumber = new Semiring(numMul, numAdd, 1, 0);
    var semigroupString = new Semigroup(concatString);
    var ringNumber = new Ring(numSub, function () {
        return semiringNumber;
    });
    var pure = function (dict) {
        return dict.pure;
    };
    var $$return = function (__dict_Monad_5) {
        return pure(__dict_Monad_5["__superclass_Prelude.Applicative_0"]());
    };
    var moduloSemiringNumber = new ModuloSemiring(numDiv, function () {
        return semiringNumber;
    }, function (_48) {
        return function (_49) {
            return 0;
        };
    });
    var liftA1 = function (__dict_Applicative_8) {
        return function (f) {
            return function (a) {
                return $less$times$greater(__dict_Applicative_8["__superclass_Prelude.Apply_0"]())(pure(__dict_Applicative_8)(f))(a);
            };
        };
    };
    var eqNumber = new Eq(refIneq, refEq);
    
    /**
     *  | Returns its first argument and ignores its second.
     */
    var $$const = function (_42) {
        return function (_43) {
            return _42;
        };
    };
    var ap = function (__dict_Monad_16) {
        return function (f) {
            return function (a) {
                return $greater$greater$eq(__dict_Monad_16["__superclass_Prelude.Bind_1"]())(f)(function (_2) {
                    return $greater$greater$eq(__dict_Monad_16["__superclass_Prelude.Bind_1"]())(a)(function (_1) {
                        return $$return(__dict_Monad_16)(_2(_1));
                    });
                });
            };
        };
    };
    return {
        Unit: Unit, 
        Semigroup: Semigroup, 
        Eq: Eq, 
        Ring: Ring, 
        ModuloSemiring: ModuloSemiring, 
        Semiring: Semiring, 
        Monad: Monad, 
        Bind: Bind, 
        Applicative: Applicative, 
        Apply: Apply, 
        Functor: Functor, 
        Show: Show, 
        unit: unit, 
        "++": $plus$plus, 
        "<>": $less$greater, 
        refIneq: refIneq, 
        refEq: refEq, 
        "==": $eq$eq, 
        "-": $minus, 
        "/": $div, 
        "+": $plus, 
        ap: ap, 
        "return": $$return, 
        ">>=": $greater$greater$eq, 
        liftA1: liftA1, 
        pure: pure, 
        "<*>": $less$times$greater, 
        "<$>": $less$dollar$greater, 
        show: show, 
        "$": $dollar, 
        "const": $$const, 
        showNumber: showNumber, 
        semiringNumber: semiringNumber, 
        ringNumber: ringNumber, 
        moduloSemiringNumber: moduloSemiringNumber, 
        eqNumber: eqNumber, 
        semigroupString: semigroupString
    };
})();
var PS = PS || {};
PS.Data_Function = (function () {
    "use strict";
    var Prelude = PS.Prelude;
    
    function runFn2(fn) {
      return function(a) {
        return function(b) {
          return fn(a, b);
        };
      };
    }
    ;
    
    function runFn3(fn) {
      return function(a) {
        return function(b) {
          return function(c) {
            return fn(a, b, c);
          };
        };
      };
    }
    ;
    return {
        runFn3: runFn3, 
        runFn2: runFn2
    };
})();
var PS = PS || {};
PS.Control_Monad_Eff = (function () {
    "use strict";
    var Prelude = PS.Prelude;
    
    function returnE(a) {
      return function() {
        return a;
      };
    }
    ;
    
    function bindE(a) {
      return function(f) {
        return function() {
          return f(a())();
        };
      };
    }
    ;
    var monadEff = new Prelude.Monad(function () {
        return applicativeEff;
    }, function () {
        return bindEff;
    });
    var bindEff = new Prelude.Bind(bindE, function () {
        return applyEff;
    });
    var applyEff = new Prelude.Apply(Prelude.ap(monadEff), function () {
        return functorEff;
    });
    var applicativeEff = new Prelude.Applicative(function () {
        return applyEff;
    }, returnE);
    var functorEff = new Prelude.Functor(Prelude.liftA1(applicativeEff));
    return {
        bindE: bindE, 
        returnE: returnE, 
        functorEff: functorEff, 
        applyEff: applyEff, 
        applicativeEff: applicativeEff, 
        bindEff: bindEff, 
        monadEff: monadEff
    };
})();
var PS = PS || {};
PS.Control_Monad_Eff_Exception = (function () {
    "use strict";
    var Prelude = PS.Prelude;
    var Control_Monad_Eff = PS.Control_Monad_Eff;
    
  function error(msg) {
    return new Error(msg);
  }
  ;
    return {
        error: error
    };
})();
var PS = PS || {};
PS.Debug_Trace = (function () {
    "use strict";
    var Prelude = PS.Prelude;
    var Control_Monad_Eff = PS.Control_Monad_Eff;
    
    function trace(s) {
      return function() {
        console.log(s);
        return {};
      };
    }
    ;
    return {
        trace: trace
    };
})();
var PS = PS || {};
PS.Control_Alt = (function () {
    "use strict";
    var Prelude = PS.Prelude;
    
    /**
     *  | The `Alt` type class identifies an associative operation on a type
     *  | constructor.  It is similar to `Semigroup`, except that it applies to
     *  | types of kind `* -> *`, like `Array` or `List`, rather than concrete types
     *  | `String` or `Number`.
     *  |
     *  | `Alt` instances are required to satisfy the following laws:
     *  |
     *  | - Associativity: `(x <|> y) <|> z == x <|> (y <|> z)`
     *  | - Distributivity: `f <$> (x <|> y) == (f <$> x) <|> (f <$> y)`
     *  |
     *  | For example, the `Array` (`[]`) type is an instance of `Alt`, where
     *  | `(<|>)` is defined to be concatenation.
     */
    var Alt = function ($less$bar$greater, __superclass_Prelude$dotFunctor_0) {
        this["<|>"] = $less$bar$greater;
        this["__superclass_Prelude.Functor_0"] = __superclass_Prelude$dotFunctor_0;
    };
    
    /**
     *  | The `Alt` type class identifies an associative operation on a type
     *  | constructor.  It is similar to `Semigroup`, except that it applies to
     *  | types of kind `* -> *`, like `Array` or `List`, rather than concrete types
     *  | `String` or `Number`.
     *  |
     *  | `Alt` instances are required to satisfy the following laws:
     *  |
     *  | - Associativity: `(x <|> y) <|> z == x <|> (y <|> z)`
     *  | - Distributivity: `f <$> (x <|> y) == (f <$> x) <|> (f <$> y)`
     *  |
     *  | For example, the `Array` (`[]`) type is an instance of `Alt`, where
     *  | `(<|>)` is defined to be concatenation.
     */
    var $less$bar$greater = function (dict) {
        return dict["<|>"];
    };
    return {
        Alt: Alt, 
        "<|>": $less$bar$greater
    };
})();
var PS = PS || {};
PS.Data_Either = (function () {
    "use strict";
    var Prelude = PS.Prelude;
    var Control_Alt = PS.Control_Alt;
    var Control_Extend = PS.Control_Extend;
    
    /**
     *  | The `Either` type is used to represent a choice between two types of value.
     *  |
     *  | A common use case for `Either` is error handling, where `Left` is used to
     *  | carry an error value and `Right` is used to carry a success value.
     */
    var Left = (function () {
        function Left(value0) {
            this.value0 = value0;
        };
        Left.create = function (value0) {
            return new Left(value0);
        };
        return Left;
    })();
    
    /**
     *  | The `Either` type is used to represent a choice between two types of value.
     *  |
     *  | A common use case for `Either` is error handling, where `Left` is used to
     *  | carry an error value and `Right` is used to carry a success value.
     */
    var Right = (function () {
        function Right(value0) {
            this.value0 = value0;
        };
        Right.create = function (value0) {
            return new Right(value0);
        };
        return Right;
    })();
    
    /**
     *  | Takes two functions and an `Either` value, if the value is a `Left` the
     *  | inner value is applied to the first function, if the value is a `Right`
     *  | the inner value is applied to the second function.
     *  |
     *  | ``` purescript
     *  | either f g (Left x) == f x
     *  | either f g (Right y) == g y
     *  | ```
     */
    var either = function (_86) {
        return function (_87) {
            return function (_88) {
                if (_88 instanceof Left) {
                    return _86(_88.value0);
                };
                if (_88 instanceof Right) {
                    return _87(_88.value0);
                };
                throw new Error("Failed pattern match");
            };
        };
    };
    return {
        Left: Left, 
        Right: Right, 
        either: either
    };
})();
var PS = PS || {};
PS.Control_Monad_Eff_Class = (function () {
    "use strict";
    var Prelude = PS.Prelude;
    var Control_Monad_Trans = PS.Control_Monad_Trans;
    var Data_Monoid = PS.Data_Monoid;
    var Control_Monad_Eff = PS.Control_Monad_Eff;
    var Control_Monad_Maybe_Trans = PS.Control_Monad_Maybe_Trans;
    var Control_Monad_Error_Trans = PS.Control_Monad_Error_Trans;
    var Control_Monad_State_Trans = PS.Control_Monad_State_Trans;
    var Control_Monad_Writer_Trans = PS.Control_Monad_Writer_Trans;
    var Control_Monad_Reader_Trans = PS.Control_Monad_Reader_Trans;
    var Control_Monad_RWS_Trans = PS.Control_Monad_RWS_Trans;
    
    /**
     *  | The `MonadEff` class captures those monads which support native effects.
     *  |
     *  | Instances are provided for `Eff` itself, and the standard monad transformers.
     *  |
     *  | `liftEff` can be used in any appropriate monad transformer stack to lift an action
     *  | of type `Eff eff a` into the monad.
     *  |
     *  | Note that `MonadEff` is parameterized by the row of effects, so type inference can be
     *  | tricky. It is generally recommended to either work with a polymorphic row of effects,
     *  | or a concrete, closed row of effects such as `(trace :: Trace)`.
     */
    var MonadEff = function (__superclass_Prelude$dotMonad_0, liftEff) {
        this["__superclass_Prelude.Monad_0"] = __superclass_Prelude$dotMonad_0;
        this.liftEff = liftEff;
    };
    
    /**
     *  | The `MonadEff` class captures those monads which support native effects.
     *  |
     *  | Instances are provided for `Eff` itself, and the standard monad transformers.
     *  |
     *  | `liftEff` can be used in any appropriate monad transformer stack to lift an action
     *  | of type `Eff eff a` into the monad.
     *  |
     *  | Note that `MonadEff` is parameterized by the row of effects, so type inference can be
     *  | tricky. It is generally recommended to either work with a polymorphic row of effects,
     *  | or a concrete, closed row of effects such as `(trace :: Trace)`.
     */
    var liftEff = function (dict) {
        return dict.liftEff;
    };
    return {
        MonadEff: MonadEff, 
        liftEff: liftEff
    };
})();
var PS = PS || {};
PS.Control_Monad_Error_Class = (function () {
    "use strict";
    var Prelude = PS.Prelude;
    var Control_Monad_Error_Trans = PS.Control_Monad_Error_Trans;
    var Control_Monad_Trans = PS.Control_Monad_Trans;
    var Control_Monad_Maybe_Trans = PS.Control_Monad_Maybe_Trans;
    var Control_Monad_Reader_Trans = PS.Control_Monad_Reader_Trans;
    var Control_Monad_Writer_Trans = PS.Control_Monad_Writer_Trans;
    var Control_Monad_State_Trans = PS.Control_Monad_State_Trans;
    var Control_Monad_Error = PS.Control_Monad_Error;
    var Data_Either = PS.Data_Either;
    var Data_Maybe = PS.Data_Maybe;
    var Data_Monoid = PS.Data_Monoid;
    
    /**
     *  | The `MonadError` type class represents those monads which support errors via
     *  | `throwError` and `catchError`.
     *  |
     *  | - `throwError e` throws the error `e`
     *  | - `catchError x f` calls the error handler `f` if an error is thrown during the
     *  |   evaluation of `x`.
     *  |
     *  | An implementation is provided for `ErrorT`, and for other monad transformers
     *  | defined in this library.
     *  |
     *  | Laws:
     *  |
     *  | - Left zero: `throwError e >>= f = throwError e`
     *  | - Catch: `catchError (throwError e) f = f e`
     *  | - Pure: `catchError (pure a) f = pure a`
     *  | 
     */
    var MonadError = function (catchError, throwError) {
        this.catchError = catchError;
        this.throwError = throwError;
    };
    
    /**
     *  | The `MonadError` type class represents those monads which support errors via
     *  | `throwError` and `catchError`.
     *  |
     *  | - `throwError e` throws the error `e`
     *  | - `catchError x f` calls the error handler `f` if an error is thrown during the
     *  |   evaluation of `x`.
     *  |
     *  | An implementation is provided for `ErrorT`, and for other monad transformers
     *  | defined in this library.
     *  |
     *  | Laws:
     *  |
     *  | - Left zero: `throwError e >>= f = throwError e`
     *  | - Catch: `catchError (throwError e) f = f e`
     *  | - Pure: `catchError (pure a) f = pure a`
     *  | 
     */
    var throwError = function (dict) {
        return dict.throwError;
    };
    return {
        MonadError: MonadError, 
        throwError: throwError
    };
})();
var PS = PS || {};
PS.Control_Monad_Aff = (function () {
    "use strict";
    var Prelude = PS.Prelude;
    var Data_Function = PS.Data_Function;
    var Data_Monoid = PS.Data_Monoid;
    var Data_Either = PS.Data_Either;
    var Control_Monad_Error_Class = PS.Control_Monad_Error_Class;
    var Control_Monad_Eff_Exception = PS.Control_Monad_Eff_Exception;
    var Control_Apply = PS.Control_Apply;
    var Control_Alt = PS.Control_Alt;
    var Control_Plus = PS.Control_Plus;
    var Control_Alternative = PS.Control_Alternative;
    var Control_MonadPlus = PS.Control_MonadPlus;
    var Control_Monad_Eff = PS.Control_Monad_Eff;
    var Control_Monad_Eff_Unsafe = PS.Control_Monad_Eff_Unsafe;
    var Control_Monad_Eff_Class = PS.Control_Monad_Eff_Class;
    
    function _setTimeout(nonCanceler, millis, aff) {
      return function(success, error) {
        var canceler;
        var cancel = false;

        var timeout = setTimeout(function() {
          if (!cancel) {
            canceler = aff(success, error);
          }
        }, millis);

        return function(e) {
          return function(success, error) {
            if (canceler !== undefined) {
              return canceler(e)(success, error);
            } else {
              cancel = true;
              clearTimeout(timeout);
              error(e);
              return nonCanceler;
            }
          };
        };
      };
    }
  ;
    
    function _forkAff(canceler, aff) {
      return function(success, error) {
        var canceler = aff(function(){}, function(){});

        try {
          success(canceler);
        } catch (e) {
          error(e);
        }

        return canceler;
      };
    }
  ;
    
    function _pure(canceler, v) {
      return function(success, error) {
        try {
          success(v);
        } catch (e) {
          error(e);
        }
        
        return canceler;
      }
    };
    
    function _throwError(canceler, e) {
      return function(success, error) {
        error(e);
        
        return canceler;
      }
    };
    
    function _fmap(f, aff) {
      return function(success, error) {
        return aff(function(v) {
          try {
            success(f(v));
          } catch (e) {
            error(e);
          }
        }, error);
      };
    };
    
    function _bind(aff, f) {
      return function(success, error) {
        var canceler;
        
        canceler = aff(function(v) {
          try {        
            canceler = f(v)(success, error);
          } catch (e) {
            error(e);
          }
        }, error);
        
        return function(e) {
          return function(success, error) {
            return canceler(e)(success, error);
          }
        };
      };
    };
    
    function _attempt(Left, Right, aff) {
      return function(success, error) {
        return aff(function(v) {
          try {
            success(Right(v));
          } catch (e) {
            error(e);
          }
        }, function(e) {
          try {
            success(Left(e));
          } catch (e) {
            error(e);
          }
        });
      };
    };
    
    function _runAff(errorT, successT, aff) {
      return function() {
        return aff(function(v) {
          try {
            successT(v)();
          } catch (e) {
            errorT(e)();
          }
        }, function(e) {
          errorT(e)();
        });
      };
    };
    
    function _liftEff(canceler, e) {
      return function(success, error) {
        try {
          success(e());
        } catch (e) {
          error(e);
        }
        
        return canceler;
      };
    };
    
    /**
     *  | Runs the asynchronous computation. You must supply an error callback and a 
     *  | success callback.
     */
    var runAff = function (ex) {
        return function (f) {
            return function (aff) {
                return _runAff(ex, f, aff);
            };
        };
    };
    
    /**
     *  | Converts the asynchronous computation into a synchronous one. All values 
     *  | and errors are ignored.
     */
    var launchAff = runAff(Prelude["const"](Prelude.pure(Control_Monad_Eff.applicativeEff)(Prelude.unit)))(Prelude["const"](Prelude.pure(Control_Monad_Eff.applicativeEff)(Prelude.unit)));
    var functorAff = new Prelude.Functor(function (f) {
        return function (fa) {
            return _fmap(f, fa);
        };
    });
    
    /**
     *  | Promotes any error to the value level of the asynchronous monad.
     */
    var attempt = function (aff) {
        return _attempt(Data_Either.Left.create, Data_Either.Right.create, aff);
    };
    var applyAff = new Prelude.Apply(function (ff) {
        return function (fa) {
            return _bind(ff, function (f) {
                return Prelude["<$>"](functorAff)(f)(fa);
            });
        };
    }, function () {
        return functorAff;
    });
    var bindAff = new Prelude.Bind(function (fa) {
        return function (f) {
            return _bind(fa, f);
        };
    }, function () {
        return applyAff;
    });
    var applicativeAff = new Prelude.Applicative(function () {
        return applyAff;
    }, function (v) {
        return _pure(nonCanceler, v);
    });
    var nonCanceler = Prelude["const"](Prelude.pure(applicativeAff)(false));
    var monadAff = new Prelude.Monad(function () {
        return applicativeAff;
    }, function () {
        return bindAff;
    });
    
    /**
     *  | Forks the specified asynchronous computation so subsequent monadic binds 
     *  | will not block on the result of the computation.
     */
    var forkAff = function (aff) {
        return _forkAff(nonCanceler, aff);
    };
    
    /**
     *  | Runs the asynchronous computation later (off the current execution context).
     */
    var later$prime = function (n) {
        return function (aff) {
            return _setTimeout(nonCanceler, n, aff);
        };
    };
    
    /**
     *  | Runs the asynchronous computation off the current execution context.
     */
    var later = later$prime(0);
    var monadEffAff = new Control_Monad_Eff_Class.MonadEff(function () {
        return monadAff;
    }, function (eff) {
        return _liftEff(nonCanceler, eff);
    });
    
    /**
     *  | Allows users to catch and throw errors on the error channel of the 
     *  | asynchronous computation. See documentation in `purescript-transformers`.
     */
    var monadErrorAff = new Control_Monad_Error_Class.MonadError(function (aff) {
        return function (ex) {
            return Prelude[">>="](bindAff)(attempt(aff))(Data_Either.either(ex)(Prelude.pure(applicativeAff)));
        };
    }, function (e) {
        return _throwError(nonCanceler, e);
    });
    
    /**
     *  | Ignores any errors.
     */
    var apathize = function (a) {
        return Prelude["<$>"](functorAff)(Prelude["const"](Prelude.unit))(attempt(a));
    };
    return {
        runAff: runAff, 
        nonCanceler: nonCanceler, 
        launchAff: launchAff, 
        "later'": later$prime, 
        later: later, 
        forkAff: forkAff, 
        attempt: attempt, 
        apathize: apathize, 
        functorAff: functorAff, 
        applyAff: applyAff, 
        applicativeAff: applicativeAff, 
        bindAff: bindAff, 
        monadAff: monadAff, 
        monadEffAff: monadEffAff, 
        monadErrorAff: monadErrorAff
    };
})();
var PS = PS || {};
PS.Control_Monad_Aff_AVar = (function () {
    "use strict";
    var Control_Monad_Aff = PS.Control_Monad_Aff;
    var Prelude = PS.Prelude;
    var Data_Function = PS.Data_Function;
    var Control_Monad_Eff_Exception = PS.Control_Monad_Eff_Exception;
    
    function _makeVar(canceler) {
      return function(success, error) {
        try {
          success({
            consumers: [],
            producers: [],
            error: undefined 
          });
        } catch (e) {
          error(e);
        }

        return canceler;
      }
    }
  ;
    
    function _takeVar(canceler, avar) {
      return function(success, error) {
        if (avar.error !== undefined) {
          error(avar.error);
        } else if (avar.producers.length > 0) {
          var producer = avar.producers.shift();

          producer(success, error);
        } else {
          avar.consumers.push({success: success, error: error});
        }

        return canceler;
      } 
    }
  ;
    
    function _putVar(canceler, avar, a) {
      return function(success, error) {
        if (avar.error !== undefined) {
          error(avar.error);
        } else if (avar.consumers.length === 0) {
          avar.producers.push(function(success, error) {
            try {
              success(a);
            } catch (e) {
              error(e);
            }
          });

          success({});
        } else {
          var consumer = avar.consumers.shift();

          try {
            consumer.success(a);
          } catch (e) {
            error(e);

            return;                  
          }

          success({});
        }

        return canceler;
      }
    }
  ;
    
    function _killVar(canceler, avar, e) {
      return function(success, error) {
        if (avar.error !== undefined) {
          error(avar.error);
        } else {
          var errors = [];

          avar.error = e;

          while (avar.consumers.length > 0) {
            var consumer = avar.consumers.shift();

            try {
              consumer.error(e);
            } catch (e) {
              errors.push(e);              
            }
          }

          if (errors.length > 0) error(errors[0]);
          else success({});
        }

        return canceler;
      }
    }
  ;
    
    /**
     *  | Takes the next value from the asynchronous avar.
     */
    var takeVar = function (q) {
        return _takeVar(Control_Monad_Aff.nonCanceler, q);
    };
    
    /**
     *  | Puts a new value into the asynchronous avar. If the avar has
     *  | been killed, this will result in an error.
     */
    var putVar = function (q) {
        return function (a) {
            return _putVar(Control_Monad_Aff.nonCanceler, q, a);
        };
    };
    
    /**
     *  | Makes a new asynchronous avar.
     */
    var makeVar = _makeVar(Control_Monad_Aff.nonCanceler);
    
    /**
     *  | Makes a avar and sets it to some value.
     */
    var makeVar$prime = function (a) {
        return Prelude[">>="](Control_Monad_Aff.bindAff)(makeVar)(function (_24) {
            return Prelude[">>="](Control_Monad_Aff.bindAff)(putVar(_24)(a))(function () {
                return Prelude["return"](Control_Monad_Aff.monadAff)(_24);
            });
        });
    };
    
    /**
     *  | Kills an asynchronous avar.
     */
    var killVar = function (q) {
        return function (e) {
            return _killVar(Control_Monad_Aff.nonCanceler, q, e);
        };
    };
    return {
        takeVar: takeVar, 
        putVar: putVar, 
        "makeVar'": makeVar$prime, 
        makeVar: makeVar, 
        killVar: killVar
    };
})();
var PS = PS || {};
PS.Control_Monad_Aff_Par = (function () {
    "use strict";
    var Prelude = PS.Prelude;
    var Data_Monoid = PS.Data_Monoid;
    var Control_Monad_Aff_AVar = PS.Control_Monad_Aff_AVar;
    var Control_Monad_Aff = PS.Control_Monad_Aff;
    var Data_Either = PS.Data_Either;
    var Control_Plus = PS.Control_Plus;
    var Control_Apply = PS.Control_Apply;
    var Control_Alt = PS.Control_Alt;
    var Control_Alternative = PS.Control_Alternative;
    var Control_Monad_Error_Class = PS.Control_Monad_Error_Class;
    var Par = function (x) {
        return x;
    };
    
    /**
     *  | Extracts the `Aff` from the `Par`.
     */
    var runPar = function (_296) {
        return _296;
    };
    var functorPar = new Prelude.Functor(function (_297) {
        return function (_298) {
            return Prelude["<$>"](Control_Monad_Aff.functorAff)(_297)(_298);
        };
    });
    
    /**
     *  | Returns the first value, or the first error if both error.
     */
    var altPar = new Control_Alt.Alt(function (_301) {
        return function (_302) {
            var maybeKill = function (va) {
                return function (ve) {
                    return function (err) {
                        return Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff_AVar.takeVar(ve))(function (_27) {
                            return Prelude[">>="](Control_Monad_Aff.bindAff)((function () {
                                var _491 = _27 === 1;
                                if (_491) {
                                    return Control_Monad_Aff_AVar.killVar(va)(err);
                                };
                                if (!_491) {
                                    return Prelude["return"](Control_Monad_Aff.monadAff)(Prelude.unit);
                                };
                                throw new Error("Failed pattern match");
                            })())(function () {
                                return Control_Monad_Aff_AVar.putVar(ve)(_27 + 1);
                            });
                        });
                    };
                };
            };
            return Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff_AVar.makeVar)(function (_29) {
                return Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff_AVar["makeVar'"](0))(function (_28) {
                    return Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff.forkAff(Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff.attempt(_301))(Data_Either.either(maybeKill(_29)(_28))(Control_Monad_Aff_AVar.putVar(_29)))))(function () {
                        return Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff.forkAff(Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff.attempt(_302))(Data_Either.either(maybeKill(_29)(_28))(Control_Monad_Aff_AVar.putVar(_29)))))(function () {
                            return Control_Monad_Aff_AVar.takeVar(_29);
                        });
                    });
                });
            });
        };
    }, function () {
        return functorPar;
    });
    return {
        Par: Par, 
        runPar: runPar, 
        functorPar: functorPar, 
        altPar: altPar
    };
})();
var PS = PS || {};
PS.Examples = (function () {
    "use strict";
    var Prelude = PS.Prelude;
    var Control_Monad_Eff_Class = PS.Control_Monad_Eff_Class;
    var Debug_Trace = PS.Debug_Trace;
    var Control_Monad_Aff = PS.Control_Monad_Aff;
    var Control_Monad_Error_Class = PS.Control_Monad_Error_Class;
    var Control_Monad_Eff_Exception = PS.Control_Monad_Eff_Exception;
    var Data_Either = PS.Data_Either;
    var Control_Monad_Aff_AVar = PS.Control_Monad_Aff_AVar;
    var Control_Monad_Aff_Par = PS.Control_Monad_Aff_Par;
    var Control_Alt = PS.Control_Alt;
    var Control_Apply = PS.Control_Apply;
    var test_sequencing = function (_472) {
        if (_472 === 0) {
            return Control_Monad_Eff_Class.liftEff(Control_Monad_Aff.monadEffAff)(Debug_Trace.trace("Done"));
        };
        return Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff["later'"](100)(Control_Monad_Eff_Class.liftEff(Control_Monad_Aff.monadEffAff)(Debug_Trace.trace(Prelude.show(Prelude.showNumber)(_472 / 10) + " seconds left"))))(function () {
            return test_sequencing(_472 - 1);
        });
    };
    var test_putTakeQueue = Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff_AVar.makeVar)(function (_36) {
        return Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff.forkAff(Control_Monad_Aff.later(Control_Monad_Aff_AVar.putVar(_36)(1.0))))(function () {
            return Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff_AVar.takeVar(_36))(function (_35) {
                return Control_Monad_Eff_Class.liftEff(Control_Monad_Aff.monadEffAff)(Debug_Trace.trace("Success: Value " + Prelude.show(Prelude.showNumber)(_35)));
            });
        });
    });
    var test_pure = Prelude[">>="](Control_Monad_Aff.bindAff)(Prelude.pure(Control_Monad_Aff.applicativeAff)(Prelude.unit))(function () {
        return Prelude[">>="](Control_Monad_Aff.bindAff)(Prelude.pure(Control_Monad_Aff.applicativeAff)(Prelude.unit))(function () {
            return Prelude[">>="](Control_Monad_Aff.bindAff)(Prelude.pure(Control_Monad_Aff.applicativeAff)(Prelude.unit))(function () {
                return Control_Monad_Eff_Class.liftEff(Control_Monad_Aff.monadEffAff)(Debug_Trace.trace("Success: Got all the way past 4 pures"));
            });
        });
    });
    var test_parRaceKill2 = Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff.attempt(Control_Monad_Aff_Par.runPar(Control_Alt["<|>"](Control_Monad_Aff_Par.altPar)(Control_Monad_Aff["later'"](100)(Control_Monad_Error_Class.throwError(Control_Monad_Aff.monadErrorAff)(Control_Monad_Eff_Exception.error("Oh noes!"))))(Control_Monad_Aff["later'"](200)(Control_Monad_Error_Class.throwError(Control_Monad_Aff.monadErrorAff)(Control_Monad_Eff_Exception.error("Oh noes!")))))))(function (_41) {
        return Control_Monad_Eff_Class.liftEff(Control_Monad_Aff.monadEffAff)(Data_Either.either(Prelude["const"](Debug_Trace.trace("Success: Killing both kills it dead")))(Prelude["const"](Debug_Trace.trace("Failure: It's alive!!!")))(_41));
    });
    var test_parRaceKill1 = Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff_Par.runPar(Control_Alt["<|>"](Control_Monad_Aff_Par.altPar)(Control_Monad_Aff["later'"](100)(Control_Monad_Error_Class.throwError(Control_Monad_Aff.monadErrorAff)(Control_Monad_Eff_Exception.error("Oh noes!"))))(Control_Monad_Aff["later'"](200)(Prelude.pure(Control_Monad_Aff.applicativeAff)("Success: Early error was ignored in favor of late success")))))(function (_40) {
        return Control_Monad_Eff_Class.liftEff(Control_Monad_Aff.monadEffAff)(Debug_Trace.trace(_40));
    });
    var test_parRace = Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff_Par.runPar(Control_Alt["<|>"](Control_Monad_Aff_Par.altPar)(Control_Monad_Aff["later'"](100)(Prelude.pure(Control_Monad_Aff.applicativeAff)("Success: Early bird got the worm")))(Control_Monad_Aff["later'"](200)(Prelude.pure(Control_Monad_Aff.applicativeAff)("Failure: Late bird got the worm")))))(function (_39) {
        return Control_Monad_Eff_Class.liftEff(Control_Monad_Aff.monadEffAff)(Debug_Trace.trace(_39));
    });
    var test_killQueue = Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff_AVar.makeVar)(function (_38) {
        return Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff_AVar.killVar(_38)(Control_Monad_Eff_Exception.error("DOA")))(function () {
            return Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff.attempt(Control_Monad_Aff_AVar.takeVar(_38)))(function (_37) {
                return Control_Monad_Eff_Class.liftEff(Control_Monad_Aff.monadEffAff)(Data_Either.either(Prelude["const"](Debug_Trace.trace("Success: Killed queue dead")))(Prelude["const"](Debug_Trace.trace("Failure: Oh noes, queue survived!")))(_37));
            });
        });
    });
    var test_attempt = Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff.attempt(Control_Monad_Error_Class.throwError(Control_Monad_Aff.monadErrorAff)(Control_Monad_Eff_Exception.error("Oh noes!"))))(function (_34) {
        return Control_Monad_Eff_Class.liftEff(Control_Monad_Aff.monadEffAff)(Data_Either.either(Prelude["const"](Debug_Trace.trace("Success: Exception caught")))(Prelude["const"](Debug_Trace.trace("Failure: Exception NOT caught!!!")))(_34));
    });
    var test_apathize = Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff.apathize(Control_Monad_Error_Class.throwError(Control_Monad_Aff.monadErrorAff)(Control_Monad_Eff_Exception.error("Oh noes!"))))(function () {
        return Control_Monad_Eff_Class.liftEff(Control_Monad_Aff.monadEffAff)(Debug_Trace.trace("Success: Exceptions don't stop the apathetic"));
    });
    var main = Control_Monad_Aff.launchAff(Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Eff_Class.liftEff(Control_Monad_Aff.monadEffAff)(Debug_Trace.trace("Testing sequencing")))(function () {
        return Prelude[">>="](Control_Monad_Aff.bindAff)(test_sequencing(3))(function () {
            return Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Eff_Class.liftEff(Control_Monad_Aff.monadEffAff)(Debug_Trace.trace("Testing pure")))(function () {
                return Prelude[">>="](Control_Monad_Aff.bindAff)(test_pure)(function () {
                    return Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Eff_Class.liftEff(Control_Monad_Aff.monadEffAff)(Debug_Trace.trace("Testing attempt")))(function () {
                        return Prelude[">>="](Control_Monad_Aff.bindAff)(test_attempt)(function () {
                            return Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Eff_Class.liftEff(Control_Monad_Aff.monadEffAff)(Debug_Trace.trace("Testing later")))(function () {
                                return Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Aff.later(Control_Monad_Eff_Class.liftEff(Control_Monad_Aff.monadEffAff)(Debug_Trace.trace("Success: It happened later"))))(function () {
                                    return Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Eff_Class.liftEff(Control_Monad_Aff.monadEffAff)(Debug_Trace.trace("Testing apathize")))(function () {
                                        return Prelude[">>="](Control_Monad_Aff.bindAff)(test_apathize)(function () {
                                            return Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Eff_Class.liftEff(Control_Monad_Aff.monadEffAff)(Debug_Trace.trace("Testing Queue - putVar, takeVar")))(function () {
                                                return Prelude[">>="](Control_Monad_Aff.bindAff)(test_putTakeQueue)(function () {
                                                    return Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Eff_Class.liftEff(Control_Monad_Aff.monadEffAff)(Debug_Trace.trace("Testing killVar")))(function () {
                                                        return Prelude[">>="](Control_Monad_Aff.bindAff)(test_killQueue)(function () {
                                                            return Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Eff_Class.liftEff(Control_Monad_Aff.monadEffAff)(Debug_Trace.trace("Testing Par (<|>)")))(function () {
                                                                return Prelude[">>="](Control_Monad_Aff.bindAff)(test_parRace)(function () {
                                                                    return Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Eff_Class.liftEff(Control_Monad_Aff.monadEffAff)(Debug_Trace.trace("Testing Par (<|>) - kill one")))(function () {
                                                                        return Prelude[">>="](Control_Monad_Aff.bindAff)(test_parRaceKill1)(function () {
                                                                            return Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_Eff_Class.liftEff(Control_Monad_Aff.monadEffAff)(Debug_Trace.trace("Testing Par (<|>) - kill two")))(function () {
                                                                                return Prelude[">>="](Control_Monad_Aff.bindAff)(test_parRaceKill2)(function () {
                                                                                    return Control_Monad_Eff_Class.liftEff(Control_Monad_Aff.monadEffAff)(Debug_Trace.trace("Done testing"));
                                                                                });
                                                                            });
                                                                        });
                                                                    });
                                                                });
                                                            });
                                                        });
                                                    });
                                                });
                                            });
                                        });
                                    });
                                });
                            });
                        });
                    });
                });
            });
        });
    }));
    return {
        main: main, 
        test_parRaceKill2: test_parRaceKill2, 
        test_parRaceKill1: test_parRaceKill1, 
        test_parRace: test_parRace, 
        test_killQueue: test_killQueue, 
        test_putTakeQueue: test_putTakeQueue, 
        test_apathize: test_apathize, 
        test_attempt: test_attempt, 
        test_pure: test_pure, 
        test_sequencing: test_sequencing
    };
})();
PS.Examples.main();
